<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸµ MIDI Clip æ’­æ”¾é©—è­‰ - å°æ˜Ÿæ˜Ÿä¸‰è²éƒ¨å’Œè²ç‰ˆæœ¬</title>
    <!-- Tone.js CDN -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #2d3748, #4a5568);
            border-radius: 15px;
            border: 2px solid #4a5568;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }
        
        .header p {
            font-size: 1.2rem;
            color: #e2e8f0;
            margin-bottom: 20px;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px 25px;
            background: #2d3748;
            border-radius: 10px;
            border: 1px solid #4a5568;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-loading { background: rgba(245, 158, 11, 0.2); border: 1px solid #f59e0b; }
        .status-ready { background: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; }
        .status-error { background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; }
        .status-playing { background: rgba(59, 130, 246, 0.2); border: 1px solid #3b82f6; }
        
        .main-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-section {
            background: #2d3748;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #4a5568;
        }
        
        .control-section h3 {
            color: #ffd700;
            font-size: 1.3rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin: 5px;
            display: inline-block;
        }
        
        .btn:hover { transform: translateY(-2px); opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .btn-primary { background: #3182ce; color: white; }
        .btn-success { background: #38a169; color: white; }
        .btn-warning { background: #d69e2e; color: white; }
        .btn-danger { background: #e53e3e; color: white; }
        .btn-info { background: #00b4d8; color: white; }
        .btn-secondary { background: #718096; color: white; }
        
        .btn-large {
            font-size: 18px;
            padding: 20px 30px;
            min-width: 250px;
        }
        
        .track-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .track-card {
            background: #2d3748;
            border-radius: 12px;
            padding: 25px;
            border: 2px solid #4a5568;
            transition: all 0.3s;
        }
        
        .track-card:hover {
            border-color: #ffd700;
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.2);
        }
        
        .track-card.active {
            border-color: #ffd700;
            background: #374151;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .track-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #ffd700;
        }
        
        .track-range {
            font-size: 12px;
            color: #a0aec0;
            background: #4a5568;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .track-info {
            margin-bottom: 15px;
            font-size: 14px;
            color: #e2e8f0;
        }
        
        .track-info div {
            margin-bottom: 5px;
        }
        
        .note-sequence {
            background: #1a202c;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #4a5568;
        }
        
        .note-sequence h5 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .notes-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .note-item {
            background: #4a5568;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .note-item.high { background: #e53e3e; }
        .note-item.mid { background: #38a169; }
        .note-item.low { background: #3182ce; }
        
        .track-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .console {
            background: #0a0a0a;
            border-radius: 10px;
            border: 2px solid #4a5568;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .console-header {
            background: #1a202c;
            padding: 15px 20px;
            border-bottom: 1px solid #4a5568;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 10px 10px 0 0;
        }
        
        .console-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .log-filters {
            display: flex;
            gap: 5px;
            margin-right: 10px;
        }
        
        .log-filters .btn {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .log-entry.hidden {
            display: none;
        }
        
        .error-summary {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a202c;
            border: 2px solid #e53e3e;
            border-radius: 10px;
            padding: 20px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .error-summary-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
        
        .console-title {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .console-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .log-entry {
            margin-bottom: 6px;
            display: flex;
            align-items: flex-start;
        }
        
        .log-time {
            color: #718096;
            margin-right: 15px;
            min-width: 90px;
            font-size: 11px;
        }
        
        .log-success { color: #68d391; }
        .log-error { color: #fc8181; }
        .log-warning { color: #f6e05e; }
        .log-info { color: #63b3ed; }
        .log-debug { color: #a0aec0; }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffd700;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #4a5568;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-item {
            background: #2d3748;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #4a5568;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #a0aec0;
        }
        
        /* æ¸¬è©¦çµ„æ¨£å¼ */
        .test-groups {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .test-group {
            border: 1px solid #4a5568;
            border-radius: 6px;
            background: #1a202c;
        }
        
        .test-group-header {
            width: 100%;
            padding: 8px 12px;
            background: transparent;
            border: none;
            color: #ffd700;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .test-group-header:hover {
            background: #2d3748;
        }
        
        .test-group-content {
            padding: 8px 12px;
            display: none;
            flex-wrap: wrap;
            gap: 6px;
            border-top: 1px solid #4a5568;
            background: #2d3748;
        }
        
        .test-group-content.expanded {
            display: flex;
        }
        
        .btn-sm {
            padding: 6px 10px;
            font-size: 11px;
            min-width: auto;
        }
        
        .test-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .test-results {
            background: #1a202c;
            border-radius: 4px;
            padding: 8px;
            border: 1px solid #4a5568;
        }
        
        .log-filters .btn.active {
            background: #3182ce !important;
            border-color: #3182ce !important;
            box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ğŸµ MIDI Clip æ’­æ”¾é©—è­‰</h1>
            <p>å°æ˜Ÿæ˜Ÿæ—‹å¾‹ - ä¸‰è²éƒ¨å’Œè²ç‰ˆæœ¬æ¸¬è©¦ (ä¸»æ—‹å¾‹ + å’Œè² + ä½éŸ³)</p>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="trackCount">0</div>
                    <div class="stat-label">è»Œé“æ•¸é‡</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="clipCount">0</div>
                    <div class="stat-label">MIDI ç‰‡æ®µ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="noteCount">0</div>
                    <div class="stat-label">éŸ³ç¬¦ç¸½æ•¸</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="playbackStatus">å¾…æ©Ÿ</div>
                    <div class="stat-label">æ’­æ”¾ç‹€æ…‹</div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span>ğŸµ Music BC ç‹€æ…‹:</span>
                <div class="status-indicator status-loading" id="systemStatus">
                    <span class="loading-spinner"></span> è¼‰å…¥ä¸­...
                </div>
            </div>
            <div class="status-item">
                <span>ğŸ”Š éŸ³é »ç‹€æ…‹:</span>
                <div class="status-indicator status-error" id="audioStatus">
                    ğŸ”‡ æœªåˆå§‹åŒ–
                </div>
            </div>
            <div class="status-item">
                <span>â±ï¸ ç•¶å‰æ™‚é–“:</span>
                <span id="currentTime">00:00:00</span>
            </div>
        </div>

        <!-- Main Controls -->
        <div class="main-controls">
            <div class="control-section">
                <h3>ğŸ›ï¸ ç³»çµ±æ§åˆ¶</h3>
                <button class="btn btn-primary btn-large" onclick="initializeSystem()" id="initBtn">
                    ğŸš€ åˆå§‹åŒ–ç³»çµ±
                </button>
                <button class="btn btn-success btn-large" onclick="createTwinkleTracks()" id="createBtn" disabled>
                    ğŸŒŸ å‰µå»ºå°æ˜Ÿæ˜Ÿè»Œé“
                </button>
                <button class="btn btn-warning" onclick="clearAllTracks()" id="clearBtn" disabled>
                    ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰è»Œé“
                </button>
            </div>

            <div class="control-section">
                <h3>ğŸ® æ’­æ”¾æ§åˆ¶</h3>
                <button class="btn btn-success btn-large" onclick="playAllTracks()" id="playAllBtn" disabled>
                    â–¶ï¸ æ’­æ”¾å…¨éƒ¨ï¼ˆä¸‰éŸ³åŸŸï¼‰
                </button>
                <button class="btn btn-danger btn-large" onclick="stopAllTracks()" id="stopBtn" disabled>
                    â¹ï¸ åœæ­¢æ’­æ”¾
                </button>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="control-section">
                <h3>ğŸ”§ æ¸¬è©¦æ§åˆ¶</h3>
                <button class="btn btn-info" onclick="playSequential()" id="sequentialBtn" disabled>
                    ğŸµ ä¾åºæ’­æ”¾ï¼ˆé«˜â†’ä¸­â†’ä½ï¼‰
                </button>
                <button class="btn btn-secondary" onclick="testSingleTrack('high')" id="testHighBtn" disabled>
                    ğŸ”´ æ¸¬è©¦é«˜éŸ³è»Œé“
                </button>
                <button class="btn btn-secondary" onclick="testSingleTrack('mid')" id="testMidBtn" disabled>
                    ğŸŸ¢ æ¸¬è©¦ä¸­éŸ³è»Œé“
                </button>
                <button class="btn btn-secondary" onclick="testSingleTrack('low')" id="testLowBtn" disabled>
                    ğŸ”µ æ¸¬è©¦ä½éŸ³è»Œé“
                </button>
            </div>

            <div class="control-section">
                <h3>âš¡ æ€§èƒ½æ¸¬è©¦</h3>
                <button class="btn btn-warning" onclick="performanceTestBasic()" id="perfTestBasicBtn" disabled>
                    ğŸš€ åŸºç¤æ€§èƒ½æ¸¬è©¦
                </button>
                <button class="btn btn-danger" onclick="performanceTestHeavy()" id="perfTestHeavyBtn" disabled>
                    ğŸ”¥ é‡åº¦è² è¼‰æ¸¬è©¦
                </button>
                <button class="btn btn-info" onclick="performanceTestMemory()" id="perfTestMemoryBtn" disabled>
                    ğŸ’¾ è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦
                </button>
                <button class="btn btn-secondary" onclick="performanceTestConcurrency()" id="perfTestConcurrencyBtn" disabled>
                    ğŸ”„ ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦
                </button>
                <div style="margin-top: 10px; font-size: 12px; color: #a0aec0;">
                    <div id="perfResults">æ€§èƒ½æ¸¬è©¦çµæœå°‡é¡¯ç¤ºåœ¨é€™è£¡</div>
                </div>
            </div>

            <div class="control-section">
                <h3>ğŸ§ª å…¨é¢æ¸¬è©¦å¥—ä»¶</h3>
                <div class="test-groups">
                    <!-- åŠŸèƒ½æ€§æ¸¬è©¦ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('functional')">
                            ğŸ¯ åŠŸèƒ½æ€§æ¸¬è©¦ <span id="functional-icon">â–¼</span>
                        </button>
                        <div class="test-group-content" id="functional-tests">
                            <button class="btn btn-info btn-sm" onclick="testMidiAccuracy()" disabled>ğŸµ MIDIç²¾ç¢ºæ€§</button>
                            <button class="btn btn-info btn-sm" onclick="testTrackOperations()" disabled>ğŸ›ï¸ è»Œé“æ“ä½œ</button>
                            <button class="btn btn-info btn-sm" onclick="testClipOperations()" disabled>âœ‚ï¸ ç‰‡æ®µæ“ä½œ</button>
                        </div>
                    </div>

                    <!-- ç©©å®šæ€§æ¸¬è©¦ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('stability')">
                            ğŸ›¡ï¸ ç©©å®šæ€§æ¸¬è©¦ <span id="stability-icon">â–¼</span>
                        </button>
                        <div class="test-group-content" id="stability-tests">
                            <button class="btn btn-warning btn-sm" onclick="testDurability()" disabled>â±ï¸ è€ä¹…æ€§æ¸¬è©¦</button>
                            <button class="btn btn-warning btn-sm" onclick="testExceptionHandling()" disabled>ğŸš¨ ç•°å¸¸è™•ç†</button>
                            <button class="btn btn-warning btn-sm" onclick="testMemoryLeaks()" disabled>ğŸ” è¨˜æ†¶é«”æ´©æ¼</button>
                        </div>
                    </div>

                    <!-- é‚Šç•Œæ¸¬è©¦ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('edge')">
                            ğŸ”¬ é‚Šç•Œæ¸¬è©¦ <span id="edge-icon">â–¼</span>
                        </button>
                        <div class="test-group-content" id="edge-tests">
                            <button class="btn btn-danger btn-sm" onclick="testExtremeValues()" disabled>ğŸ¯ æ¥µé™å€¼æ¸¬è©¦</button>
                            <button class="btn btn-danger btn-sm" onclick="testLargeScale()" disabled>ğŸ“Š å¤§è¦æ¨¡æ¸¬è©¦</button>
                            <button class="btn btn-danger btn-sm" onclick="testEdgeCases()" disabled>âš ï¸ é‚Šç•Œæƒ…æ³</button>
                        </div>
                    </div>

                    <!-- éŸ³æ¨‚æ€§æ¸¬è©¦ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('musical')">
                            ğŸ¼ éŸ³æ¨‚æ€§æ¸¬è©¦ <span id="musical-icon">â–¼</span>
                        </button>
                        <div class="test-group-content" id="musical-tests">
                            <button class="btn btn-success btn-sm" onclick="testHarmony()" disabled>ğŸ¹ å’Œè²æ¸¬è©¦</button>
                            <button class="btn btn-success btn-sm" onclick="testRhythm()" disabled>ğŸ¥ ç¯€å¥æ¸¬è©¦</button>
                            <button class="btn btn-success btn-sm" onclick="testScales()" disabled>ğŸ¶ éŸ³éšæ¸¬è©¦</button>
                        </div>
                    </div>

                    <!-- ç”¨æˆ¶é«”é©—æ¸¬è©¦ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('ux')">
                            ğŸ¨ é«”é©—æ¸¬è©¦ <span id="ux-icon">â–¼</span>
                        </button>
                        <div class="test-group-content" id="ux-tests">
                            <button class="btn btn-primary btn-sm" onclick="testResponsiveness()" disabled>âš¡ éŸ¿æ‡‰æ€§æ¸¬è©¦</button>
                            <button class="btn btn-primary btn-sm" onclick="testAudioQuality()" disabled>ğŸ”Š éŸ³è³ªæ¸¬è©¦</button>
                            <button class="btn btn-primary btn-sm" onclick="testRealTimeEditing()" disabled>âœï¸ å¯¦æ™‚ç·¨è¼¯</button>
                        </div>
                    </div>

                    <!-- æ•´åˆæ¸¬è©¦ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('integration')">
                            ğŸ”„ æ•´åˆæ¸¬è©¦ <span id="integration-icon">â–¼</span>
                        </button>
                        <div class="test-group-content" id="integration-tests">
                            <button class="btn btn-secondary btn-sm" onclick="testCrossFeatures()" disabled>ğŸ¯ è·¨åŠŸèƒ½æ¸¬è©¦</button>
                            <button class="btn btn-secondary btn-sm" onclick="testDataPersistence()" disabled>ğŸ’¾ æ•¸æ“šæŒä¹…åŒ–</button>
                            <button class="btn btn-secondary btn-sm" onclick="testFullWorkflow()" disabled>ğŸ”„ å®Œæ•´å·¥ä½œæµ</button>
                        </div>
                    </div>
                </div>
                
                <div class="test-controls" style="margin-top: 15px;">
                    <button class="btn btn-success" onclick="runAllTests()" disabled id="runAllTestsBtn">
                        ğŸš€ é‹è¡Œå…¨éƒ¨æ¸¬è©¦
                    </button>
                    <button class="btn btn-warning" onclick="runSelectedTests()" disabled id="runSelectedBtn">
                        âœ… é‹è¡Œé¸ä¸­æ¸¬è©¦
                    </button>
                    <button class="btn btn-danger" onclick="stopAllTests()" disabled id="stopTestsBtn">
                        â¹ï¸ åœæ­¢æ¸¬è©¦
                    </button>
                </div>
                
                <div class="test-results" style="margin-top: 10px;">
                    <div style="font-size: 12px; color: #a0aec0; margin-bottom: 5px;">æ¸¬è©¦çµæœæ¦‚è¦½:</div>
                    <div id="testResultsSummary" style="font-size: 11px; color: #718096;">ç­‰å¾…æ¸¬è©¦é‹è¡Œ...</div>
                </div>
            </div>
        </div>

        <!-- Track Grid -->
        <div class="track-grid" id="trackGrid">
            <!-- Track cards will be dynamically generated -->
        </div>

        <!-- Console -->
        <div class="console">
            <div class="console-header">
                <div class="console-title">ğŸ“Š ç³»çµ±æ—¥èªŒ</div>
                <div class="console-controls">
                    <div class="log-filters">
                        <button class="btn btn-sm" onclick="filterLogs('all')" id="filterAll">å…¨éƒ¨</button>
                        <button class="btn btn-sm btn-danger" onclick="filterLogs('error')" id="filterError">âŒ éŒ¯èª¤ (<span id="errorCount">0</span>)</button>
                        <button class="btn btn-sm btn-warning" onclick="filterLogs('warning')" id="filterWarning">âš ï¸ è­¦å‘Š (<span id="warningCount">0</span>)</button>
                        <button class="btn btn-sm btn-info" onclick="filterLogs('info')" id="filterInfo">â„¹ï¸ ä¿¡æ¯</button>
                        <button class="btn btn-sm btn-success" onclick="filterLogs('success')" id="filterSuccess">âœ… æˆåŠŸ</button>
                    </div>
                    <button class="btn btn-secondary" onclick="clearConsole()">æ¸…é™¤æ—¥èªŒ</button>
                    <button class="btn btn-danger" onclick="showErrorSummary()">ğŸš¨ éŒ¯èª¤æ‘˜è¦</button>
                </div>
            </div>
            <div class="console-content" id="consoleContent">
                <div class="log-entry">
                    <span class="log-time">[00:00:00]</span>
                    <span class="log-info">ğŸµ MIDI Clip æ’­æ”¾é©—è­‰ç³»çµ±æ­£åœ¨åˆå§‹åŒ–...</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // éæ¿¾ç€è¦½å™¨æ“´å±•éŒ¯èª¤
        window.addEventListener('error', (event) => {
            if (event.filename && (
                event.filename.includes('inpage.js') || 
                event.filename.includes('content-script') ||
                event.filename.includes('extension') ||
                event.filename.includes('metamask')
            )) {
                event.preventDefault();
                return false;
            }
        });
        
        // Global State
        let musicService = null;
        let isSystemReady = false;
        let isAudioReady = false;
        let tracks = {};
        let progressInterval = null;
        
        // æ™‚é–“ç¯„åœé©—è­‰è¼”åŠ©å‡½æ•¸
        function validateNoteTimeRange(noteStart, noteEnd, clipStart, clipEnd, testName) {
            const absoluteNoteStart = noteStart;
            const absoluteNoteEnd = noteEnd;
            const clipDuration = clipEnd - clipStart;
            
            if (absoluteNoteStart < 0 || absoluteNoteEnd > clipDuration) {
                const errorMsg = `${testName}: éŸ³ç¬¦æ™‚é–“è¶…å‡ºç¯„åœ - éŸ³ç¬¦[${absoluteNoteStart}-${absoluteNoteEnd}ms] è¶…å‡ºclip[0-${clipDuration}ms]`;
                log(`âš ï¸ æ™‚é–“ç¯„åœè­¦å‘Š: ${errorMsg}`, 'warning');
                return false;
            }
            return true;
        }
        
        // Track configurations for Twinkle Twinkle Little Star - Harmony Version
        const twinkleConfig = {
            high: {
                name: "ğŸ”´ ä¸»æ—‹å¾‹è»Œé“ (é«˜éŸ³)",
                range: "C4-A4 (MIDI 60-69)",
                baseNote: 60, // C4
                notes: [
                    { note: 0, duration: 500 },  // C4 - Twinkle (Cå¤§èª¿)
                    { note: 0, duration: 500 },  // C4 - twinkle 
                    { note: 7, duration: 500 },  // G4 - little (Gå¤§èª¿)
                    { note: 7, duration: 500 },  // G4 - star 
                    { note: 9, duration: 500 },  // A4 - How I (Aå°èª¿)
                    { note: 9, duration: 500 },  // A4 - wonder 
                    { note: 7, duration: 1000 }, // G4 - what you are (Gå¤§èª¿ é•·éŸ³)
                    { note: 5, duration: 500 },  // F4 - Up a- (Få¤§èª¿)
                    { note: 5, duration: 500 },  // F4 - bove the 
                    { note: 4, duration: 500 },  // E4 - world so (Cå¤§èª¿/Am)
                    { note: 4, duration: 500 },  // E4 - high 
                    { note: 2, duration: 500 },  // D4 - Like a (Gå¤§èª¿)
                    { note: 2, duration: 500 },  // D4 - diamond 
                    { note: 0, duration: 1000 }, // C4 - in the sky (Cå¤§èª¿ é•·éŸ³)
                ]
            },
            mid: {
                name: "ğŸŸ¢ å’Œè²è»Œé“ (ä¸­éŸ³)",
                range: "C3-G4 (MIDI 48-67)",
                baseNote: 48, // C3
                notes: [
                    // do-so-mi-so pattern simplified - æ¯å°ç¯€ä¸€å€‹å¾ªç’°
                    // å°ç¯€1-2: Cå¤§èª¿ (C-G-E-G)
                    { note: 0, duration: 250 },  // C3 - do
                    { note: 7, duration: 250 },  // G3 - so  
                    { note: 4, duration: 250 },  // E3 - mi
                    { note: 7, duration: 250 },  // G3 - so
                    { note: 0, duration: 250 },  // C3 - do
                    { note: 7, duration: 250 },  // G3 - so
                    { note: 4, duration: 250 },  // E3 - mi
                    { note: 7, duration: 250 },  // G3 - so
                    
                    // å°ç¯€3-4: Gå¤§èª¿ (G-D-B-D)
                    { note: 7, duration: 250 },  // G3 - do (Gå¤§èª¿)
                    { note: 14, duration: 250 }, // D4 - so (Gå¤§èª¿)
                    { note: 11, duration: 250 }, // B3 - mi (Gå¤§èª¿)  
                    { note: 14, duration: 250 }, // D4 - so (Gå¤§èª¿)
                    { note: 7, duration: 250 },  // G3 - do
                    { note: 14, duration: 250 }, // D4 - so
                    { note: 11, duration: 250 }, // B3 - mi
                    { note: 14, duration: 250 }, // D4 - so
                    
                    // å°ç¯€5-6: Aå°èª¿ (A-E-C-E)
                    { note: 9, duration: 250 },  // A3 - do (Am)
                    { note: 16, duration: 250 }, // E4 - so (Am)
                    { note: 12, duration: 250 }, // C4 - mi (Am)
                    { note: 16, duration: 250 }, // E4 - so (Am)
                    { note: 9, duration: 250 },  // A3 - do
                    { note: 16, duration: 250 }, // E4 - so
                    { note: 12, duration: 250 }, // C4 - mi  
                    { note: 16, duration: 250 }, // E4 - so
                    
                    // å°ç¯€7: Gå¤§èª¿ (G-D-B-D)
                    { note: 7, duration: 250 },  // G3 - do
                    { note: 14, duration: 250 }, // D4 - so
                    { note: 11, duration: 250 }, // B3 - mi
                    { note: 14, duration: 250 }, // D4 - so
                ]
            },
            low: {
                name: "ğŸ”µ ä½éŸ³è»Œé“ (æ ¹éŸ³)",
                range: "C2-A2 (MIDI 36-45)",
                baseNote: 36, // C2
                notes: [
                    { note: 0, duration: 1000 }, // C2 - Cå¤§èª¿æ ¹éŸ³
                    { note: 7, duration: 1000 }, // G2 - Gå¤§èª¿æ ¹éŸ³
                    { note: 9, duration: 1000 }, // A2 - Aå°èª¿æ ¹éŸ³
                    { note: 7, duration: 1000 }, // G2 - Gå¤§èª¿æ ¹éŸ³
                    { note: 5, duration: 1000 }, // F2 - Få¤§èª¿æ ¹éŸ³
                    { note: 0, duration: 1000 }, // C2 - Cå¤§èª¿æ ¹éŸ³
                    { note: 7, duration: 1000 }, // G2 - Gå¤§èª¿æ ¹éŸ³
                    { note: 0, duration: 1000 }, // C2 - Cå¤§èª¿çµæŸæ ¹éŸ³
                ]
            }
        };
        
        // å°æ˜Ÿæ˜ŸéŸ³ç¬¦åç¨±æ˜ å°„
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Initialize the system
        window.initializeSystem = async function() {
            try {
                updateSystemStatus('loading', 'è¼‰å…¥ Music BC...');
                log('ğŸš€ é–‹å§‹åˆå§‹åŒ– MIDI Clip æ’­æ”¾é©—è­‰ç³»çµ±...', 'info');
                
                // Load Music Arrangement BC
                const { MusicArrangementContainer, MusicArrangementTypes } = await import('/src/modules/music-arrangement/index.ts');
                
                log('ğŸ“¦ å‰µå»º Music BC å®¹å™¨...', 'info');
                const container = new MusicArrangementContainer();
                await container.initialize();
                
                musicService = container.get(MusicArrangementTypes.SimpleMusicArrangementService);
                
                // Initialize audio system
                log('ğŸ”Š åˆå§‹åŒ–éŸ³é »ç³»çµ±...', 'info');
                await musicService.initializeAudio();
                
                // System ready
                isSystemReady = true;
                isAudioReady = true;
                
                updateSystemStatus('ready', 'Music BC å°±ç·’');
                updateAudioStatus('ready', 'éŸ³é »å°±ç·’');
                
                // Enable controls
                document.getElementById('initBtn').disabled = true;
                document.getElementById('createBtn').disabled = false;
                
                log('âœ… ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼', 'success');
                log('ğŸµ Ready to create Twinkle Twinkle Little Star tracks!', 'success');
                
            } catch (error) {
                log(`âŒ ç³»çµ±åˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
                updateSystemStatus('error', 'åˆå§‹åŒ–å¤±æ•—');
                updateAudioStatus('error', 'éŸ³é »éŒ¯èª¤');
            }
        };
        
        // Create Twinkle Twinkle Little Star tracks
        window.createTwinkleTracks = async function() {
            try {
                if (!isSystemReady) {
                    log('âŒ ç³»çµ±å°šæœªå°±ç·’', 'error');
                    return;
                }
                
                log('ğŸŒŸ é–‹å§‹å‰µå»ºå°æ˜Ÿæ˜Ÿä¸‰è²éƒ¨å’Œè²è»Œé“...', 'info');
                updatePlaybackStatus('å‰µå»ºä¸­');
                
                // Create tracks for each range
                for (const [key, config] of Object.entries(twinkleConfig)) {
                    try {
                        log(`ğŸ›ï¸ å‰µå»º ${config.name}...`, 'info');
                        
                        // Create track
                        const trackId = await musicService.createTrack('test-user', 'INSTRUMENT', config.name);
                        log(`âœ… è»Œé“å·²å‰µå»º: ${trackId}`, 'success');
                        
                        // Create MIDI clip
                        const clipId = await musicService.createMidiClip(
                            trackId,
                            { startTime: 0, endTime: 8000 }, // 8 seconds for the full melody
                            { type: 'synth', name: `Twinkle Synth ${key.toUpperCase()}` },
                            `å°æ˜Ÿæ˜Ÿ ${key.toUpperCase()} Clip`
                        );
                        log(`ğŸ¹ MIDI Clip å·²å‰µå»º: ${clipId}`, 'success');
                        
                        // Add notes to clip
                        let currentTime = 0;
                        const noteIds = [];
                        
                        for (let i = 0; i < config.notes.length; i++) {
                            const noteConfig = config.notes[i];
                            const midiNote = config.baseNote + noteConfig.note;
                            const velocity = 100;
                            
                            const noteId = await musicService.addMidiNote(
                                trackId,
                                clipId,
                                midiNote,
                                velocity,
                                { startTime: currentTime, endTime: currentTime + noteConfig.duration }
                            );
                            
                            noteIds.push(noteId);
                            currentTime += noteConfig.duration;
                            
                            log(`ğŸµ éŸ³ç¬¦å·²æ·»åŠ : ${noteNames[noteConfig.note]} (MIDI ${midiNote}) åœ¨ ${currentTime}ms`, 'debug');
                        }
                        
                        // Store track info
                        tracks[key] = {
                            trackId,
                            clipId,
                            noteIds,
                            config,
                            noteCount: config.notes.length
                        };
                        
                        // Add track to adapter
                        await musicService.addTrackToAdapter(trackId);
                        log(`ğŸ”— è»Œé“å·²æ·»åŠ åˆ°é©é…å™¨: ${trackId}`, 'success');
                        
                    } catch (trackError) {
                        log(`âŒ å‰µå»º ${config.name} å¤±æ•—: ${trackError.message}`, 'error');
                    }
                }
                
                // Update UI
                updateTrackGrid();
                updateStats();
                updatePlaybackStatus('å°±ç·’');
                
                // Enable play controls
                document.getElementById('playAllBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('sequentialBtn').disabled = false;
                document.getElementById('testHighBtn').disabled = false;
                document.getElementById('testMidBtn').disabled = false;
                document.getElementById('testLowBtn').disabled = false;
                document.getElementById('clearBtn').disabled = false;
                
                // Enable performance test controls
                document.getElementById('perfTestBasicBtn').disabled = false;
                document.getElementById('perfTestHeavyBtn').disabled = false;
                document.getElementById('perfTestMemoryBtn').disabled = false;
                document.getElementById('perfTestConcurrencyBtn').disabled = false;
                
                // Enable all comprehensive test controls
                enableAllTestButtons();
                document.getElementById('runAllTestsBtn').disabled = false;
                document.getElementById('runSelectedBtn').disabled = false;
                document.getElementById('stopTestsBtn').disabled = false;
                
                log('ğŸ‰ æ‰€æœ‰å°æ˜Ÿæ˜Ÿè»Œé“å‰µå»ºå®Œæˆï¼', 'success');
                log(`ğŸ“Š å‰µå»ºçµ±è¨ˆ: ${Object.keys(tracks).length} å€‹è»Œé“, ç¸½è¨ˆ ${getTotalNoteCount()} å€‹éŸ³ç¬¦`, 'info');
                
            } catch (error) {
                log(`âŒ å‰µå»ºè»Œé“å¤±æ•—: ${error.message}`, 'error');
                updatePlaybackStatus('éŒ¯èª¤');
            }
        };
        
        // Play all tracks simultaneously
        window.playAllTracks = async function() {
            try {
                if (!isSystemReady || Object.keys(tracks).length === 0) {
                    log('âŒ ç³»çµ±æœªå°±ç·’æˆ–ç„¡è»Œé“å¯æ’­æ”¾', 'error');
                    return;
                }
                
                log('ğŸµ é–‹å§‹æ’­æ”¾æ‰€æœ‰è»Œé“ï¼ˆä¸‰éŸ³åŸŸåŒæ™‚æ’­æ”¾ï¼‰...', 'info');
                updatePlaybackStatus('æ’­æ”¾ä¸­');
                
                // Start progress bar
                startProgress(8000); // 8 seconds total duration
                
                // Play all tracks using Music BC
                await musicService.playAllTracks();
                
                log('âœ… ä¸‰éŸ³åŸŸå°æ˜Ÿæ˜Ÿæ’­æ”¾é–‹å§‹ï¼', 'success');
                log('ğŸ”Š ä½ æ‡‰è©²è½åˆ°é«˜ä¸­ä½éŸ³åŒæ™‚æ¼”å¥çš„å°æ˜Ÿæ˜Ÿæ—‹å¾‹', 'info');
                
                // Auto stop after duration
                setTimeout(() => {
                    updatePlaybackStatus('å®Œæˆ');
                    stopProgress();
                }, 8000);
                
            } catch (error) {
                log(`âŒ æ’­æ”¾å¤±æ•—: ${error.message}`, 'error');
                updatePlaybackStatus('éŒ¯èª¤');
                stopProgress();
            }
        };
        
        // Stop all tracks
        window.stopAllTracks = async function() {
            try {
                log('â¹ï¸ åœæ­¢æ‰€æœ‰è»Œé“æ’­æ”¾...', 'info');
                
                if (musicService) {
                    await musicService.stopAllTracks();
                }
                
                updatePlaybackStatus('å·²åœæ­¢');
                stopProgress();
                
                log('âœ… æ’­æ”¾å·²åœæ­¢', 'success');
                
            } catch (error) {
                log(`âŒ åœæ­¢æ’­æ”¾å¤±æ•—: ${error.message}`, 'error');
            }
        };
        
        // Play tracks sequentially
        window.playSequential = async function() {
            try {
                if (!isSystemReady || Object.keys(tracks).length === 0) {
                    log('âŒ ç³»çµ±æœªå°±ç·’æˆ–ç„¡è»Œé“å¯æ’­æ”¾', 'error');
                    return;
                }
                
                log('ğŸµ é–‹å§‹ä¾åºæ’­æ”¾è»Œé“ï¼ˆé«˜â†’ä¸­â†’ä½ï¼‰...', 'info');
                updatePlaybackStatus('ä¾åºæ’­æ”¾');
                
                // Start progress bar for full sequence
                startProgress(24000); // 3 x 8 seconds
                
                const sequence = ['high', 'mid', 'low'];
                
                for (let i = 0; i < sequence.length; i++) {
                    const key = sequence[i];
                    const track = tracks[key];
                    
                    if (track) {
                        log(`ğŸµ æ’­æ”¾ ${track.config.name}...`, 'info');
                        markTrackActive(key);
                        
                        // Play single track
                        await musicService.playMidiClip(track.trackId, track.clipId);
                        
                        // Wait for completion
                        await new Promise(resolve => setTimeout(resolve, 8000));
                        
                        clearTrackActive();
                        log(`âœ… ${track.config.name} æ’­æ”¾å®Œæˆ`, 'success');
                    }
                }
                
                updatePlaybackStatus('åºåˆ—å®Œæˆ');
                stopProgress();
                
                log('ğŸ‰ ä¾åºæ’­æ”¾å®Œæˆï¼', 'success');
                
            } catch (error) {
                log(`âŒ ä¾åºæ’­æ”¾å¤±æ•—: ${error.message}`, 'error');
                updatePlaybackStatus('éŒ¯èª¤');
                stopProgress();
            }
        };
        
        // Test single track
        window.testSingleTrack = async function(trackKey) {
            try {
                const track = tracks[trackKey];
                if (!track) {
                    log(`âŒ è»Œé“ ${trackKey} ä¸å­˜åœ¨`, 'error');
                    return;
                }
                
                log(`ğŸ”§ æ¸¬è©¦ ${track.config.name}...`, 'info');
                updatePlaybackStatus(`æ¸¬è©¦${trackKey.toUpperCase()}`);
                
                markTrackActive(trackKey);
                startProgress(8000);
                
                // Play the specific MIDI clip
                await musicService.playMidiClip(track.trackId, track.clipId);
                
                log(`âœ… ${track.config.name} æ¸¬è©¦é–‹å§‹`, 'success');
                log(`ğŸ”Š æ’­æ”¾ ${track.noteCount} å€‹éŸ³ç¬¦åœ¨ ${track.config.range} ç¯„åœ`, 'info');
                
                // Auto complete after duration
                setTimeout(() => {
                    updatePlaybackStatus('æ¸¬è©¦å®Œæˆ');
                    clearTrackActive();
                    stopProgress();
                }, 8000);
                
            } catch (error) {
                log(`âŒ æ¸¬è©¦ ${trackKey} è»Œé“å¤±æ•—: ${error.message}`, 'error');
                updatePlaybackStatus('æ¸¬è©¦éŒ¯èª¤');
                clearTrackActive();
                stopProgress();
            }
        };
        
        // Clear all tracks
        window.clearAllTracks = async function() {
            try {
                if (Object.keys(tracks).length === 0) {
                    log('âš ï¸ æ²’æœ‰è»Œé“éœ€è¦æ¸…é™¤', 'warning');
                    return;
                }
                
                if (!confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è»Œé“å—ï¼Ÿ')) {
                    return;
                }
                
                log('ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰è»Œé“...', 'info');
                
                // Stop any playing tracks
                await stopAllTracks();
                
                // Clear tracks data
                tracks = {};
                
                // Update UI
                updateTrackGrid();
                updateStats();
                updatePlaybackStatus('å·²æ¸…é™¤');
                
                // Disable controls
                document.getElementById('playAllBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('sequentialBtn').disabled = true;
                document.getElementById('testHighBtn').disabled = true;
                document.getElementById('testMidBtn').disabled = true;
                document.getElementById('testLowBtn').disabled = true;
                document.getElementById('clearBtn').disabled = true;
                
                // Disable performance test controls
                document.getElementById('perfTestBasicBtn').disabled = true;
                document.getElementById('perfTestHeavyBtn').disabled = true;
                document.getElementById('perfTestMemoryBtn').disabled = true;
                document.getElementById('perfTestConcurrencyBtn').disabled = true;
                
                // Disable all comprehensive test controls
                disableAllTestButtons();
                document.getElementById('runAllTestsBtn').disabled = true;
                document.getElementById('runSelectedBtn').disabled = true;
                document.getElementById('stopTestsBtn').disabled = true;
                
                log('âœ… æ‰€æœ‰è»Œé“å·²æ¸…é™¤', 'success');
                
            } catch (error) {
                log(`âŒ æ¸…é™¤è»Œé“å¤±æ•—: ${error.message}`, 'error');
            }
        };
        
        // Update track grid UI
        function updateTrackGrid() {
            const grid = document.getElementById('trackGrid');
            grid.innerHTML = '';
            
            if (Object.keys(tracks).length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #718096;">
                        <div style="font-size: 48px; margin-bottom: 16px;">ğŸµ</div>
                        <div style="font-size: 18px; margin-bottom: 8px;">å°šæœªå‰µå»ºè»Œé“</div>
                        <div style="font-size: 14px;">é»æ“Šã€Œå‰µå»ºå°æ˜Ÿæ˜Ÿè»Œé“ã€é–‹å§‹</div>
                    </div>
                `;
                return;
            }
            
            for (const [key, track] of Object.entries(tracks)) {
                const config = track.config;
                const card = document.createElement('div');
                card.className = 'track-card';
                card.id = `track-${key}`;
                
                // Generate notes display
                const notesHtml = config.notes.slice(0, 20).map((note, index) => {
                    const noteName = noteNames[note.note];
                    const midiNum = config.baseNote + note.note;
                    return `<div class="note-item ${key}" title="MIDI ${midiNum}">${noteName}</div>`;
                }).join('');
                
                const moreNotesText = config.notes.length > 20 ? 
                    `<div class="note-item" style="background: #718096;">+${config.notes.length - 20} æ›´å¤š...</div>` : '';
                
                card.innerHTML = `
                    <div class="track-header">
                        <div class="track-title">${config.name}</div>
                        <div class="track-range">${config.range}</div>
                    </div>
                    <div class="track-info">
                        <div>ğŸ“‹ è»Œé“ID: ${track.trackId.substring(0, 12)}...</div>
                        <div>ğŸ¹ ç‰‡æ®µID: ${track.clipId.substring(0, 12)}...</div>
                        <div>ğŸµ éŸ³ç¬¦æ•¸é‡: ${track.noteCount} å€‹</div>
                        <div>â±ï¸ ç¸½æ™‚é•·: 8.0 ç§’</div>
                    </div>
                    <div class="note-sequence">
                        <h5>ğŸ¼ ${key === 'mid' ? 'do-so-mi-so 8åˆ†éŸ³ç¬¦æ¨¡å¼' : 'å°æ˜Ÿæ˜Ÿæ—‹å¾‹éŸ³ç¬¦'}:</h5>
                        <div class="notes-display">${notesHtml}${moreNotesText}</div>
                    </div>
                    <div class="track-controls">
                        <button class="btn btn-primary" onclick="testSingleTrack('${key}')">
                            â–¶ï¸ æ’­æ”¾æ­¤è»Œé“
                        </button>
                        <button class="btn btn-info" onclick="inspectTrack('${key}')">
                            ğŸ” æª¢æŸ¥ç‹€æ…‹
                        </button>
                    </div>
                `;
                
                grid.appendChild(card);
            }
        }
        
        // Mark track as active
        function markTrackActive(trackKey) {
            clearTrackActive();
            const card = document.getElementById(`track-${trackKey}`);
            if (card) {
                card.classList.add('active');
            }
        }
        
        // Clear all track active states
        function clearTrackActive() {
            document.querySelectorAll('.track-card').forEach(card => {
                card.classList.remove('active');
            });
        }
        
        // Inspect track state
        window.inspectTrack = async function(trackKey) {
            try {
                const track = tracks[trackKey];
                if (!track) {
                    log(`âŒ è»Œé“ ${trackKey} ä¸å­˜åœ¨`, 'error');
                    return;
                }
                
                log(`ğŸ” æª¢æŸ¥ ${track.config.name} ç‹€æ…‹...`, 'info');
                
                // Debug adapter state
                await musicService.debugAdapterState();
                
                // Debug audio chain
                await musicService.debugAudioChain(track.trackId);
                
                log(`ğŸ“Š è»Œé“è©³æƒ…:`, 'info');
                log(`  è»Œé“ID: ${track.trackId}`, 'debug');
                log(`  ç‰‡æ®µID: ${track.clipId}`, 'debug');
                log(`  éŸ³ç¬¦æ•¸é‡: ${track.noteCount}`, 'debug');
                log(`  éŸ³åŸŸç¯„åœ: ${track.config.range}`, 'debug');
                log(`  åŸºæº–éŸ³ç¬¦: ${track.config.baseNote}`, 'debug');
                
                log(`âœ… ${track.config.name} ç‹€æ…‹æª¢æŸ¥å®Œæˆ`, 'success');
                
            } catch (error) {
                log(`âŒ æª¢æŸ¥è»Œé“ ${trackKey} å¤±æ•—: ${error.message}`, 'error');
            }
        };
        
        // Update statistics
        function updateStats() {
            document.getElementById('trackCount').textContent = Object.keys(tracks).length;
            document.getElementById('clipCount').textContent = Object.keys(tracks).length;
            document.getElementById('noteCount').textContent = getTotalNoteCount();
        }
        
        // Get total note count
        function getTotalNoteCount() {
            return Object.values(tracks).reduce((total, track) => total + track.noteCount, 0);
        }
        
        // Update system status
        function updateSystemStatus(type, text) {
            const status = document.getElementById('systemStatus');
            const iconMap = {
                'loading': '<span class="loading-spinner"></span>',
                'ready': 'âœ…',
                'error': 'âŒ'
            };
            
            status.innerHTML = `${iconMap[type]} ${text}`;
            status.className = `status-indicator status-${type}`;
        }
        
        // Update audio status
        function updateAudioStatus(type, text) {
            const status = document.getElementById('audioStatus');
            const iconMap = {
                'loading': 'ğŸ”„',
                'ready': 'ğŸ”Š',
                'error': 'ğŸ”‡'
            };
            
            status.innerHTML = `${iconMap[type]} ${text}`;
            status.className = `status-indicator status-${type}`;
        }
        
        // Update playback status
        function updatePlaybackStatus(status) {
            document.getElementById('playbackStatus').textContent = status;
        }
        
        // Progress bar management
        function startProgress(duration) {
            const fill = document.getElementById('progressFill');
            const startTime = Date.now();
            
            progressInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                fill.style.width = progress + '%';
                
                if (progress >= 100) {
                    stopProgress();
                }
            }, 50);
        }
        
        function stopProgress() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            document.getElementById('progressFill').style.width = '0%';
        }
        
        // Console management
        let logEntries = [];
        let currentLogFilter = 'all';
        
        function log(message, type = 'info') {
            const output = document.getElementById('consoleContent');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.setAttribute('data-type', type);
            entry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-${type}">${message}</span>
            `;
            
            // Store entry data
            const logData = {
                time,
                message,
                type,
                element: entry
            };
            logEntries.push(logData);
            
            output.appendChild(entry);
            output.scrollTop = output.scrollHeight;
            
            // Update counters
            updateLogCounters();
            
            // Apply current filter
            if (currentLogFilter !== 'all' && type !== currentLogFilter) {
                entry.classList.add('hidden');
            }
        }
        
        function updateLogCounters() {
            const errorCount = logEntries.filter(entry => entry.type === 'error').length;
            const warningCount = logEntries.filter(entry => entry.type === 'warning').length;
            
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('warningCount').textContent = warningCount;
            
            // Update filter button styles
            const errorBtn = document.getElementById('filterError');
            const warningBtn = document.getElementById('filterWarning');
            
            if (errorCount > 0) {
                errorBtn.style.background = '#e53e3e';
                errorBtn.style.animation = 'pulse 2s infinite';
            }
            
            if (warningCount > 0) {
                warningBtn.style.background = '#d69e2e';
            }
        }
        
        // Filter logs by type
        window.filterLogs = function(type) {
            currentLogFilter = type;
            
            // Reset all filter button styles
            document.querySelectorAll('.log-filters .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activate current filter button
            document.getElementById(`filter${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.add('active');
            
            // Show/hide log entries
            logEntries.forEach(entry => {
                if (type === 'all' || entry.type === type) {
                    entry.element.classList.remove('hidden');
                } else {
                    entry.element.classList.add('hidden');
                }
            });
            
            log(`ğŸ“‹ æ—¥èªŒéæ¿¾: ${type === 'all' ? 'é¡¯ç¤ºå…¨éƒ¨' : type}`, 'info');
        };
        
        // Show error summary
        window.showErrorSummary = function() {
            const errors = logEntries.filter(entry => entry.type === 'error');
            const warnings = logEntries.filter(entry => entry.type === 'warning');
            
            if (errors.length === 0 && warnings.length === 0) {
                log('âœ… æ²’æœ‰ç™¼ç¾éŒ¯èª¤æˆ–è­¦å‘Šï¼', 'success');
                return;
            }
            
            // Create backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'error-summary-backdrop';
            backdrop.onclick = closeErrorSummary;
            
            // Create summary modal
            const modal = document.createElement('div');
            modal.className = 'error-summary';
            modal.id = 'errorSummaryModal';
            
            let summaryContent = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="color: #e53e3e; margin: 0;">ğŸš¨ éŒ¯èª¤èˆ‡è­¦å‘Šæ‘˜è¦</h3>
                    <button class="btn btn-secondary" onclick="closeErrorSummary()">âœ•</button>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="background: #2d3748; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="color: #e53e3e; font-size: 18px; margin-bottom: 10px;">âŒ éŒ¯èª¤ (${errors.length} é …)</div>
                        <div style="color: #d69e2e; font-size: 16px;">âš ï¸ è­¦å‘Š (${warnings.length} é …)</div>
                    </div>
                </div>
            `;
            
            if (errors.length > 0) {
                summaryContent += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #e53e3e; margin-bottom: 10px;">ğŸ”¥ éŒ¯èª¤è©³æƒ…:</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #0a0a0a; border-radius: 6px; padding: 10px;">
                `;
                
                errors.forEach((error, index) => {
                    summaryContent += `
                        <div style="margin-bottom: 8px; padding: 8px; background: #1a1a1a; border-left: 3px solid #e53e3e; border-radius: 4px;">
                            <div style="color: #718096; font-size: 11px; margin-bottom: 4px;">[${error.time}] éŒ¯èª¤ #${index + 1}</div>
                            <div style="color: #fc8181; font-size: 13px;">${error.message}</div>
                        </div>
                    `;
                });
                
                summaryContent += `</div></div>`;
            }
            
            if (warnings.length > 0) {
                summaryContent += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #d69e2e; margin-bottom: 10px;">âš ï¸ è­¦å‘Šè©³æƒ…:</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #0a0a0a; border-radius: 6px; padding: 10px;">
                `;
                
                warnings.forEach((warning, index) => {
                    summaryContent += `
                        <div style="margin-bottom: 8px; padding: 8px; background: #1a1a1a; border-left: 3px solid #d69e2e; border-radius: 4px;">
                            <div style="color: #718096; font-size: 11px; margin-bottom: 4px;">[${warning.time}] è­¦å‘Š #${index + 1}</div>
                            <div style="color: #f6e05e; font-size: 13px;">${warning.message}</div>
                        </div>
                    `;
                });
                
                summaryContent += `</div></div>`;
            }
            
            // Add suggestions
            summaryContent += `
                <div style="background: #2d3748; padding: 15px; border-radius: 8px; border-left: 4px solid #3182ce;">
                    <h4 style="color: #63b3ed; margin-bottom: 10px;">ğŸ’¡ å»ºè­°:</h4>
                    <ul style="color: #e2e8f0; padding-left: 20px; margin: 0;">
                        <li>æª¢æŸ¥ç¶²çµ¡é€£æ¥å’ŒéŸ³é »è¨­å‚™è¨­ç½®</li>
                        <li>ç¢ºä¿ç€è¦½å™¨å·²å•Ÿç”¨éŸ³é »æ’­æ”¾æ¬Šé™</li>
                        <li>å˜—è©¦é‡æ–°åˆå§‹åŒ–ç³»çµ±</li>
                        <li>æŸ¥çœ‹ç€è¦½å™¨æ§åˆ¶å°æ˜¯å¦æœ‰é¡å¤–éŒ¯èª¤ä¿¡æ¯</li>
                    </ul>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-success" onclick="copyErrorReport()">ğŸ“‹ è¤‡è£½éŒ¯èª¤å ±å‘Š</button>
                    <button class="btn btn-warning" onclick="filterLogs('error'); closeErrorSummary();">ğŸ” æŸ¥çœ‹éŒ¯èª¤æ—¥èªŒ</button>
                </div>
            `;
            
            modal.innerHTML = summaryContent;
            
            // Add to page
            document.body.appendChild(backdrop);
            document.body.appendChild(modal);
        };
        
        // Close error summary
        window.closeErrorSummary = function() {
            const backdrop = document.querySelector('.error-summary-backdrop');
            const modal = document.getElementById('errorSummaryModal');
            
            if (backdrop) backdrop.remove();
            if (modal) modal.remove();
        };
        
        // Copy error report
        window.copyErrorReport = function() {
            const errors = logEntries.filter(entry => entry.type === 'error');
            const warnings = logEntries.filter(entry => entry.type === 'warning');
            
            let report = `ğŸš¨ MIDI Clip æ’­æ”¾é©—è­‰ç³»çµ± - éŒ¯èª¤å ±å‘Š\n`;
            report += `ğŸ“… ç”Ÿæˆæ™‚é–“: ${new Date().toLocaleString()}\n`;
            report += `ğŸ“Š çµ±è¨ˆ: ${errors.length} å€‹éŒ¯èª¤, ${warnings.length} å€‹è­¦å‘Š\n\n`;
            
            if (errors.length > 0) {
                report += `âŒ éŒ¯èª¤åˆ—è¡¨:\n`;
                errors.forEach((error, index) => {
                    report += `${index + 1}. [${error.time}] ${error.message}\n`;
                });
                report += `\n`;
            }
            
            if (warnings.length > 0) {
                report += `âš ï¸ è­¦å‘Šåˆ—è¡¨:\n`;
                warnings.forEach((warning, index) => {
                    report += `${index + 1}. [${warning.time}] ${warning.message}\n`;
                });
                report += `\n`;
            }
            
            report += `ğŸŒ ç€è¦½å™¨ä¿¡æ¯: ${navigator.userAgent}\n`;
            report += `ğŸµ ç”¨æˆ¶ä»£ç†: ${navigator.platform}\n`;
            
            navigator.clipboard.writeText(report).then(() => {
                log('ğŸ“‹ éŒ¯èª¤å ±å‘Šå·²è¤‡è£½åˆ°å‰ªè²¼æ¿', 'success');
            }).catch(() => {
                log('âŒ è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸æ“‡æ–‡æœ¬', 'error');
            });
        };
        
        window.clearConsole = function() {
            document.getElementById('consoleContent').innerHTML = '';
            logEntries = [];
            updateLogCounters();
            log('ğŸ§¹ æ—¥èªŒå·²æ¸…é™¤', 'info');
        };
        
        // Update current time
        function updateCurrentTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            document.getElementById('currentTime').textContent = timeStr;
        }
        
        // Start time update
        setInterval(updateCurrentTime, 1000);
        updateCurrentTime();
        
        // Initial UI update
        updateStats();
        updateTrackGrid();
        
        // Initialization message
        log('ğŸµ MIDI Clip æ’­æ”¾é©—è­‰ç³»çµ±å·²è¼‰å…¥', 'info');
        log('ğŸŒŸ æº–å‚™æ¸¬è©¦å°æ˜Ÿæ˜Ÿä¸‰éŸ³åŸŸç‰ˆæœ¬', 'info');
        log('ğŸš€ é»æ“Šã€Œåˆå§‹åŒ–ç³»çµ±ã€é–‹å§‹', 'info');
        log('ğŸ”§ v2.1 - ä¿®å¾©æ™‚é–“ç¯„åœéŒ¯èª¤ï¼Œå„ªåŒ–æ¸¬è©¦ç©©å®šæ€§', 'info');
        
        // ============ æ€§èƒ½æ¸¬è©¦å‡½æ•¸ ============
        
        // åŸºç¤æ€§èƒ½æ¸¬è©¦
        window.performanceTestBasic = async function() {
            try {
                log('ğŸš€ é–‹å§‹åŸºç¤æ€§èƒ½æ¸¬è©¦...', 'info');
                updatePerfResults('æ¸¬è©¦ä¸­...');
                
                const startTime = performance.now();
                
                // æ¸¬è©¦è»Œé“å‰µå»ºé€Ÿåº¦
                log('ğŸ“Š æ¸¬è©¦è»Œé“å‰µå»ºæ€§èƒ½...', 'info');
                const trackCreationStart = performance.now();
                
                const testTrackId = await musicService.createTrack('perf-test', 'INSTRUMENT', 'Performance Test Track');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 2000 },
                    { type: 'synth', name: 'Perf Test Synth' },
                    'Performance Test Clip'
                );
                
                // æ·»åŠ 10å€‹éŸ³ç¬¦
                for (let i = 0; i < 10; i++) {
                    await musicService.addMidiNote(
                        testTrackId,
                        clipId,
                        60 + (i % 12),
                        100,
                        { startTime: i * 100, endTime: (i * 100) + 100 }
                    );
                }
                
                const trackCreationEnd = performance.now();
                const creationTime = trackCreationEnd - trackCreationStart;
                
                // æ¸¬è©¦æ’­æ”¾éŸ¿æ‡‰é€Ÿåº¦
                log('ğŸ“Š æ¸¬è©¦æ’­æ”¾éŸ¿æ‡‰æ€§èƒ½...', 'info');
                const playbackStart = performance.now();
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                const playbackEnd = performance.now();
                const playbackTime = playbackEnd - playbackStart;
                
                const totalTime = performance.now() - startTime;
                
                const results = `
                    âœ… åŸºç¤æ€§èƒ½æ¸¬è©¦å®Œæˆ
                    ğŸ“Š è»Œé“å‰µå»ºæ™‚é–“: ${creationTime.toFixed(2)}ms
                    ğŸµ æ’­æ”¾éŸ¿æ‡‰æ™‚é–“: ${playbackTime.toFixed(2)}ms
                    â±ï¸ ç¸½æ¸¬è©¦æ™‚é–“: ${totalTime.toFixed(2)}ms
                    ğŸ¯ ç‹€æ…‹: ${creationTime < 1000 && playbackTime < 500 ? 'å„ªç§€' : creationTime < 2000 && playbackTime < 1000 ? 'è‰¯å¥½' : 'éœ€è¦å„ªåŒ–'}
                `;
                
                updatePerfResults(results);
                log('ğŸ‰ åŸºç¤æ€§èƒ½æ¸¬è©¦å®Œæˆ', 'success');
                
            } catch (error) {
                log(`âŒ åŸºç¤æ€§èƒ½æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updatePerfResults(`âŒ æ¸¬è©¦å¤±æ•—: ${error.message}`);
            }
        };
        
        // é‡åº¦è² è¼‰æ¸¬è©¦
        window.performanceTestHeavy = async function() {
            try {
                log('ğŸ”¥ é–‹å§‹é‡åº¦è² è¼‰æ¸¬è©¦...', 'info');
                updatePerfResults('é‡åº¦è² è¼‰æ¸¬è©¦ä¸­...');
                
                const startTime = performance.now();
                
                // å‰µå»ºå¤šå€‹è»Œé“å’Œå¤§é‡éŸ³ç¬¦
                log('ğŸ“Š å‰µå»º5å€‹è»Œé“ï¼Œæ¯å€‹è»Œé“100å€‹éŸ³ç¬¦...', 'info');
                const trackIds = [];
                
                for (let trackIndex = 0; trackIndex < 5; trackIndex++) {
                    const trackId = await musicService.createTrack('heavy-test', 'INSTRUMENT', `Heavy Test Track ${trackIndex + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 10000 },
                        { type: 'synth', name: `Heavy Synth ${trackIndex + 1}` },
                        `Heavy Clip ${trackIndex + 1}`
                    );
                    
                    // æ¯å€‹è»Œé“æ·»åŠ 100å€‹éŸ³ç¬¦
                    for (let noteIndex = 0; noteIndex < 100; noteIndex++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (noteIndex % 25),
                            100,
                            { startTime: noteIndex * 50, endTime: (noteIndex * 50) + 40 }
                        );
                    }
                    
                    trackIds.push(trackId);
                    await musicService.addTrackToAdapter(trackId);
                    
                    log(`âœ… è»Œé“ ${trackIndex + 1}/5 å‰µå»ºå®Œæˆ`, 'info');
                }
                
                // æ¸¬è©¦ä¸¦ç™¼æ’­æ”¾
                log('ğŸ“Š æ¸¬è©¦ä¸¦ç™¼æ’­æ”¾æ‰€æœ‰è»Œé“...', 'info');
                const playbackStart = performance.now();
                
                await musicService.playAllTracks();
                
                const playbackEnd = performance.now();
                const totalTime = performance.now() - startTime;
                
                const results = `
                    âœ… é‡åº¦è² è¼‰æ¸¬è©¦å®Œæˆ
                    ğŸ“Š å‰µå»º5è»Œé“500éŸ³ç¬¦: ${totalTime.toFixed(2)}ms
                    ğŸµ ä¸¦ç™¼æ’­æ”¾éŸ¿æ‡‰: ${(playbackEnd - playbackStart).toFixed(2)}ms
                    ğŸ’ª è² è¼‰è™•ç†èƒ½åŠ›: ${totalTime < 10000 ? 'å„ªç§€' : totalTime < 20000 ? 'è‰¯å¥½' : 'éœ€è¦å„ªåŒ–'}
                    ğŸ“ˆ å¹³å‡æ¯éŸ³ç¬¦è™•ç†: ${(totalTime / 500).toFixed(2)}ms
                `;
                
                updatePerfResults(results);
                log('ğŸ‰ é‡åº¦è² è¼‰æ¸¬è©¦å®Œæˆ', 'success');
                
                // ç­‰å¾…æ’­æ”¾å®Œæˆå¾Œæ¸…ç†
                setTimeout(async () => {
                    await musicService.stopAllTracks();
                    log('ğŸ§¹ é‡åº¦æ¸¬è©¦æ¸…ç†å®Œæˆ', 'info');
                }, 3000);
                
            } catch (error) {
                log(`âŒ é‡åº¦è² è¼‰æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updatePerfResults(`âŒ é‡åº¦æ¸¬è©¦å¤±æ•—: ${error.message}`);
            }
        };
        
        // è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦
        window.performanceTestMemory = async function() {
            try {
                log('ğŸ’¾ é–‹å§‹è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦...', 'info');
                updatePerfResults('è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦ä¸­...');
                
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const startTime = performance.now();
                
                // å‰µå»ºå¤§é‡è»Œé“ä½†ä¸æ’­æ”¾
                log('ğŸ“Š å‰µå»º20å€‹è»Œé“ç”¨æ–¼è¨˜æ†¶é«”æ¸¬è©¦...', 'info');
                const memoryTrackIds = [];
                
                for (let i = 0; i < 20; i++) {
                    const trackId = await musicService.createTrack('memory-test', 'INSTRUMENT', `Memory Test Track ${i + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 5000 },
                        { type: 'synth', name: `Memory Synth ${i + 1}` },
                        `Memory Clip ${i + 1}`
                    );
                    
                    // æ¯å€‹è»Œé“æ·»åŠ 50å€‹éŸ³ç¬¦
                    for (let j = 0; j < 50; j++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (j % 12),
                            100,
                            { startTime: j * 80, endTime: (j * 80) + 60 }
                        );
                    }
                    
                    memoryTrackIds.push(trackId);
                    
                    if (i % 5 === 4) {
                        log(`ğŸ“Š è¨˜æ†¶é«”æ¸¬è©¦é€²åº¦: ${i + 1}/20`, 'info');
                    }
                }
                
                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryUsed = finalMemory - initialMemory;
                const totalTime = performance.now() - startTime;
                
                const results = `
                    âœ… è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦å®Œæˆ
                    ğŸ“Š å‰µå»º20è»Œé“1000éŸ³ç¬¦: ${totalTime.toFixed(2)}ms
                    ğŸ’¾ è¨˜æ†¶é«”ä½¿ç”¨å¢é‡: ${(memoryUsed / 1024 / 1024).toFixed(2)} MB
                    ğŸ“ˆ å¹³å‡æ¯è»Œé“è¨˜æ†¶é«”: ${(memoryUsed / 20 / 1024).toFixed(2)} KB
                    ğŸ¯ è¨˜æ†¶é«”æ•ˆç‡: ${memoryUsed < 50 * 1024 * 1024 ? 'å„ªç§€' : memoryUsed < 100 * 1024 * 1024 ? 'è‰¯å¥½' : 'éœ€è¦å„ªåŒ–'}
                `;
                
                updatePerfResults(results);
                log('ğŸ‰ è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦å®Œæˆ', 'success');
                
            } catch (error) {
                log(`âŒ è¨˜æ†¶é«”å£“åŠ›æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updatePerfResults(`âŒ è¨˜æ†¶é«”æ¸¬è©¦å¤±æ•—: ${error.message}`);
            }
        };
        
        // ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦
        window.performanceTestConcurrency = async function() {
            try {
                log('ğŸ”„ é–‹å§‹ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦...', 'info');
                updatePerfResults('ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦ä¸­...');
                
                const startTime = performance.now();
                
                // å‰µå»º3å€‹è»Œé“ç”¨æ–¼ä¸¦ç™¼æ¸¬è©¦
                log('ğŸ“Š å‰µå»º3å€‹è»Œé“ç”¨æ–¼ä¸¦ç™¼æ¸¬è©¦...', 'info');
                const concurrentTracks = [];
                
                for (let i = 0; i < 3; i++) {
                    const trackId = await musicService.createTrack('concurrent-test', 'INSTRUMENT', `Concurrent Track ${i + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 3000 },
                        { type: 'synth', name: `Concurrent Synth ${i + 1}` },
                        `Concurrent Clip ${i + 1}`
                    );
                    
                    // æ¯å€‹è»Œé“ä¸åŒçš„éŸ³ç¬¦æ¨¡å¼
                    const baseNote = 60 + (i * 12);
                    for (let j = 0; j < 20; j++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            baseNote + (j % 8),
                            100,
                            { startTime: j * 150, endTime: (j * 150) + 100 }
                        );
                    }
                    
                    await musicService.addTrackToAdapter(trackId);
                    concurrentTracks.push({ trackId, clipId });
                }
                
                // æ¸¬è©¦ä¸¦ç™¼æ’­æ”¾
                log('ğŸ“Š æ¸¬è©¦ä¸¦ç™¼æ’­æ”¾æ€§èƒ½...', 'info');
                const concurrentStart = performance.now();
                
                // åŒæ™‚æ’­æ”¾æ‰€æœ‰è»Œé“
                const playPromises = concurrentTracks.map(track => 
                    musicService.playMidiClip(track.trackId, track.clipId)
                );
                
                await Promise.all(playPromises);
                
                const concurrentEnd = performance.now();
                const totalTime = performance.now() - startTime;
                
                const results = `
                    âœ… ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦å®Œæˆ
                    ğŸ“Š å‰µå»º3è»Œé“60éŸ³ç¬¦: ${totalTime.toFixed(2)}ms
                    ğŸ”„ ä¸¦ç™¼æ’­æ”¾å•Ÿå‹•: ${(concurrentEnd - concurrentStart).toFixed(2)}ms
                    ğŸµ ä¸¦ç™¼æ€§èƒ½: ${(concurrentEnd - concurrentStart) < 200 ? 'å„ªç§€' : 'è‰¯å¥½'}
                    âš¡ å¹³å‡è»Œé“éŸ¿æ‡‰: ${((concurrentEnd - concurrentStart) / 3).toFixed(2)}ms
                `;
                
                updatePerfResults(results);
                log('ğŸ‰ ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦å®Œæˆ', 'success');
                
                // åœæ­¢æ’­æ”¾
                setTimeout(async () => {
                    await musicService.stopAllTracks();
                    log('ğŸ§¹ ä¸¦ç™¼æ¸¬è©¦æ¸…ç†å®Œæˆ', 'info');
                }, 3000);
                
            } catch (error) {
                log(`âŒ ä¸¦ç™¼æ’­æ”¾æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updatePerfResults(`âŒ ä¸¦ç™¼æ¸¬è©¦å¤±æ•—: ${error.message}`);
            }
        };
        
        // æ›´æ–°æ€§èƒ½æ¸¬è©¦çµæœé¡¯ç¤º
        function updatePerfResults(results) {
            const resultsElement = document.getElementById('perfResults');
            if (resultsElement) {
                resultsElement.innerHTML = results.replace(/\n/g, '<br>');
            }
        }
        
        // ============ å…¨é¢æ¸¬è©¦å¥—ä»¶å¯¦ç¾ ============
        
        // æ¸¬è©¦ç‹€æ…‹ç®¡ç†
        let testResults = {};
        let isTestRunning = false;
        let testAbortController = null;
        
        // æ¸¬è©¦çµ„æ‘ºç–Š/å±•é–‹
        window.toggleTestGroup = function(groupName) {
            const content = document.getElementById(`${groupName}-tests`);
            const icon = document.getElementById(`${groupName}-icon`);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = 'â–¼';
            } else {
                content.classList.add('expanded');
                icon.textContent = 'â–²';
            }
        };
        
        // å•Ÿç”¨/ç¦ç”¨æ¸¬è©¦æŒ‰éˆ•
        function enableAllTestButtons() {
            const buttons = document.querySelectorAll('.test-group-content button');
            buttons.forEach(btn => btn.disabled = false);
        }
        
        function disableAllTestButtons() {
            const buttons = document.querySelectorAll('.test-group-content button');
            buttons.forEach(btn => btn.disabled = true);
        }
        
        // æ›´æ–°æ¸¬è©¦çµæœæ‘˜è¦
        function updateTestSummary() {
            const summary = document.getElementById('testResultsSummary');
            const total = Object.keys(testResults).length;
            const passed = Object.values(testResults).filter(r => r.status === 'passed').length;
            const failed = Object.values(testResults).filter(r => r.status === 'failed').length;
            const running = Object.values(testResults).filter(r => r.status === 'running').length;
            
            summary.innerHTML = `ç¸½è¨ˆ: ${total} | âœ… é€šé: ${passed} | âŒ å¤±æ•—: ${failed} | ğŸ”„ é‹è¡Œä¸­: ${running}`;
        }
        
        // ============ åŠŸèƒ½æ€§æ¸¬è©¦ ============
        
        // MIDIç²¾ç¢ºæ€§æ¸¬è©¦
        window.testMidiAccuracy = async function() {
            try {
                log('ğŸµ é–‹å§‹MIDIç²¾ç¢ºæ€§æ¸¬è©¦...', 'info');
                testResults['midiAccuracy'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // æ¸¬è©¦ä¸åŒMIDIå€¼çš„æº–ç¢ºæ€§
                const testTrackId = await musicService.createTrack('midi-test', 'INSTRUMENT', 'MIDIç²¾ç¢ºæ€§æ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 3000 },
                    { type: 'synth', name: 'Accuracy Test Synth' },
                    'Accuracy Test Clip'
                );
                
                // æ¸¬è©¦éŸ³ç¬¦: C4, E4, G4, C5 (å¤§ä¸‰å’Œå¼¦)
                const testNotes = [60, 64, 67, 72];
                const testVelocities = [80, 100, 120, 100];
                
                for (let i = 0; i < testNotes.length; i++) {
                    await musicService.addMidiNote(
                        testTrackId,
                        clipId,
                        testNotes[i],
                        testVelocities[i],
                        { startTime: i * 500, endTime: (i * 500) + 400 }
                    );
                    log(`ğŸµ æ¸¬è©¦éŸ³ç¬¦: MIDI ${testNotes[i]}, velocity ${testVelocities[i]}`, 'debug');
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['midiAccuracy'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['midiAccuracy'].startTime,
                    details: '4å€‹ä¸åŒMIDIéŸ³ç¬¦åŠåŠ›åº¦æ¸¬è©¦é€šé'
                };
                
                log('âœ… MIDIç²¾ç¢ºæ€§æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['midiAccuracy'] = { status: 'failed', error: error.message };
                log(`âŒ MIDIç²¾ç¢ºæ€§æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // è»Œé“æ“ä½œæ¸¬è©¦
        window.testTrackOperations = async function() {
            try {
                log('ğŸ›ï¸ é–‹å§‹è»Œé“æ“ä½œæ¸¬è©¦...', 'info');
                testResults['trackOps'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // å‹•æ…‹å‰µå»ºå¤šå€‹è»Œé“
                const trackIds = [];
                for (let i = 0; i < 5; i++) {
                    const trackId = await musicService.createTrack('track-ops', 'INSTRUMENT', `å‹•æ…‹è»Œé“ ${i + 1}`);
                    trackIds.push(trackId);
                    await musicService.addTrackToAdapter(trackId);
                    log(`ğŸ›ï¸ å‰µå»ºè»Œé“ ${i + 1}/5: ${trackId.substring(0, 12)}...`, 'debug');
                }
                
                // æ¸¬è©¦ä¸¦ç™¼æ·»åŠ éŸ³ç¬¦
                for (const trackId of trackIds) {
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 1000 },
                        { type: 'synth', name: 'Track Ops Synth' },
                        'Track Ops Clip'
                    );
                    
                    await musicService.addMidiNote(
                        trackId,
                        clipId,
                        60 + Math.floor(Math.random() * 12),
                        100,
                        { startTime: 0, endTime: 500 }
                    );
                }
                
                testResults['trackOps'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['trackOps'].startTime,
                    details: `${trackIds.length}å€‹è»Œé“å‹•æ…‹å‰µå»ºå’Œæ“ä½œæˆåŠŸ`
                };
                
                log('âœ… è»Œé“æ“ä½œæ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['trackOps'] = { status: 'failed', error: error.message };
                log(`âŒ è»Œé“æ“ä½œæ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ç‰‡æ®µæ“ä½œæ¸¬è©¦  
        window.testClipOperations = async function() {
            try {
                log('âœ‚ï¸ é–‹å§‹ç‰‡æ®µæ“ä½œæ¸¬è©¦...', 'info');
                testResults['clipOps'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('clip-ops', 'INSTRUMENT', 'ç‰‡æ®µæ“ä½œæ¸¬è©¦');
                
                // å‰µå»ºå¤šå€‹ç‰‡æ®µ
                const clipIds = [];
                for (let i = 0; i < 3; i++) {
                    const clipId = await musicService.createMidiClip(
                        testTrackId,
                        { startTime: 0, endTime: 1000 }, // ä½¿ç”¨å›ºå®šçš„0-1000msç¯„åœ
                        { type: 'synth', name: `Clip ${i + 1}` },
                        `æ¸¬è©¦ç‰‡æ®µ ${i + 1}`
                    );
                    clipIds.push(clipId);
                    
                    // æ¯å€‹ç‰‡æ®µæ·»åŠ ä¸åŒçš„éŸ³ç¬¦æ¨¡å¼
                    for (let j = 0; j < 4; j++) {
                        const noteStart = j * 200;
                        const noteEnd = noteStart + 150;
                        // ç¢ºä¿éŸ³ç¬¦åœ¨clipçš„1000msç¯„åœå…§
                        if (noteEnd <= 1000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                60 + (i * 4) + j,
                                100,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                        }
                    }
                    
                    log(`âœ‚ï¸ ç‰‡æ®µ ${i + 1}/3 å‰µå»ºå®Œæˆ`, 'debug');
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                
                testResults['clipOps'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['clipOps'].startTime,
                    details: `${clipIds.length}å€‹MIDIç‰‡æ®µå‰µå»ºå’Œæ“ä½œæˆåŠŸ`
                };
                
                log('âœ… ç‰‡æ®µæ“ä½œæ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['clipOps'] = { status: 'failed', error: error.message };
                log(`âŒ ç‰‡æ®µæ“ä½œæ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ ç©©å®šæ€§æ¸¬è©¦ ============
        
        // è€ä¹…æ€§æ¸¬è©¦
        window.testDurability = async function() {
            try {
                log('â±ï¸ é–‹å§‹è€ä¹…æ€§æ¸¬è©¦ (30ç§’é€£çºŒæ“ä½œ)...', 'info');
                testResults['durability'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const endTime = Date.now() + 30000; // 30ç§’æ¸¬è©¦
                let operationCount = 0;
                
                while (Date.now() < endTime && !testAbortController?.signal.aborted) {
                    const trackId = await musicService.createTrack('durability', 'INSTRUMENT', `è€ä¹…æ¸¬è©¦ ${operationCount}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 500 },
                        { type: 'synth', name: 'Durability Synth' },
                        'Durability Clip'
                    );
                    
                    await musicService.addMidiNote(
                        trackId,
                        clipId,
                        60 + (operationCount % 12),
                        100,
                        { startTime: 0, endTime: 300 }
                    );
                    
                    operationCount++;
                    
                    if (operationCount % 10 === 0) {
                        log(`â±ï¸ è€ä¹…æ¸¬è©¦é€²åº¦: ${operationCount} æ¬¡æ“ä½œ`, 'debug');
                    }
                    
                    // çŸ­æš«å»¶é²é¿å…éè¼‰
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                testResults['durability'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['durability'].startTime,
                    details: `30ç§’å…§å®Œæˆ ${operationCount} æ¬¡é€£çºŒæ“ä½œ`
                };
                
                log('âœ… è€ä¹…æ€§æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['durability'] = { status: 'failed', error: error.message };
                log(`âŒ è€ä¹…æ€§æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ç•°å¸¸è™•ç†æ¸¬è©¦
        window.testExceptionHandling = async function() {
            try {
                log('ğŸš¨ é–‹å§‹ç•°å¸¸è™•ç†æ¸¬è©¦...', 'info');
                testResults['exceptions'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                let testsPassed = 0;
                const totalTests = 4;
                
                // æ¸¬è©¦1: ç„¡æ•ˆè»Œé“ID
                try {
                    await musicService.playMidiClip('invalid-track-id', 'invalid-clip-id');
                    log('âš ï¸ ç„¡æ•ˆIDæ¸¬è©¦ - æ‡‰è©²æ‹‹å‡ºç•°å¸¸ä½†æ²’æœ‰', 'warning');
                } catch (e) {
                    log('âœ… ç„¡æ•ˆIDç•°å¸¸è™•ç†æ­£ç¢º', 'debug');
                    testsPassed++;
                }
                
                // æ¸¬è©¦2: æ¥µç«¯MIDIå€¼
                try {
                    const testTrackId = await musicService.createTrack('exception-test', 'INSTRUMENT', 'ç•°å¸¸è™•ç†æ¸¬è©¦');
                    const clipId = await musicService.createMidiClip(
                        testTrackId,
                        { startTime: 0, endTime: 1000 },
                        { type: 'synth', name: 'Exception Test' },
                        'Exception Clip'
                    );
                    
                    // æ¸¬è©¦é‚Šç•ŒMIDIå€¼
                    await musicService.addMidiNote(testTrackId, clipId, 0, 100, { startTime: 0, endTime: 100 });
                    await musicService.addMidiNote(testTrackId, clipId, 127, 100, { startTime: 100, endTime: 200 });
                    testsPassed++;
                    log('âœ… æ¥µç«¯MIDIå€¼è™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ æ¥µç«¯MIDIå€¼æ¸¬è©¦å¤±æ•—: ${e.message}`, 'warning');
                }
                
                // æ¸¬è©¦3: ç„¡æ•ˆæ™‚é–“ç¯„åœ
                try {
                    const testTrackId = await musicService.createTrack('time-test', 'INSTRUMENT', 'æ™‚é–“æ¸¬è©¦');
                    const clipId = await musicService.createMidiClip(
                        testTrackId,
                        { startTime: 1000, endTime: 0 }, // ç„¡æ•ˆ: çµæŸæ™‚é–“æ—©æ–¼é–‹å§‹æ™‚é–“
                        { type: 'synth', name: 'Time Test' },
                        'Time Clip'
                    );
                    log('âš ï¸ ç„¡æ•ˆæ™‚é–“ç¯„åœ - æ‡‰è©²æ‹‹å‡ºç•°å¸¸ä½†æ²’æœ‰', 'warning');
                } catch (e) {
                    log('âœ… ç„¡æ•ˆæ™‚é–“ç¯„åœç•°å¸¸è™•ç†æ­£ç¢º', 'debug');
                    testsPassed++;
                }
                
                // æ¸¬è©¦4: ç©ºæ•¸æ“šè™•ç†
                try {
                    const testTrackId = await musicService.createTrack('empty-test', 'INSTRUMENT', '');
                    testsPassed++;
                    log('âœ… ç©ºå­—ç¬¦ä¸²è™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ ç©ºå­—ç¬¦ä¸²æ¸¬è©¦: ${e.message}`, 'warning');
                }
                
                testResults['exceptions'] = { 
                    status: testsPassed >= 3 ? 'passed' : 'failed', 
                    duration: Date.now() - testResults['exceptions'].startTime,
                    details: `${testsPassed}/${totalTests} ç•°å¸¸è™•ç†æ¸¬è©¦é€šé`
                };
                
                log('âœ… ç•°å¸¸è™•ç†æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['exceptions'] = { status: 'failed', error: error.message };
                log(`âŒ ç•°å¸¸è™•ç†æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // è¨˜æ†¶é«”æ´©æ¼æ¸¬è©¦
        window.testMemoryLeaks = async function() {
            try {
                log('ğŸ” é–‹å§‹è¨˜æ†¶é«”æ´©æ¼æ¸¬è©¦...', 'info');
                testResults['memoryLeaks'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                // å‰µå»ºå’Œæ¸…ç†å¤§é‡å°è±¡
                for (let cycle = 0; cycle < 5; cycle++) {
                    const trackIds = [];
                    
                    // å‰µå»ºéšæ®µ
                    for (let i = 0; i < 20; i++) {
                        const trackId = await musicService.createTrack('memory-leak-test', 'INSTRUMENT', `Memory Test ${cycle}-${i}`);
                        const clipId = await musicService.createMidiClip(
                            trackId,
                            { startTime: 0, endTime: 1000 },
                            { type: 'synth', name: `Memory Synth ${i}` },
                            `Memory Clip ${i}`
                        );
                        
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (i % 12),
                            100,
                            { startTime: 0, endTime: 500 }
                        );
                        
                        trackIds.push(trackId);
                    }
                    
                    log(`ğŸ” è¨˜æ†¶é«”æ¸¬è©¦å¾ªç’° ${cycle + 1}/5 - å‰µå»º20å€‹è»Œé“`, 'debug');
                    
                    // å¼·åˆ¶åƒåœ¾å›æ”¶ (å¦‚æœå¯èƒ½)
                    if (window.gc) {
                        window.gc();
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = finalMemory - initialMemory;
                
                testResults['memoryLeaks'] = { 
                    status: memoryIncrease < 100 * 1024 * 1024 ? 'passed' : 'warning', // 100MBé–¾å€¼
                    duration: Date.now() - testResults['memoryLeaks'].startTime,
                    details: `è¨˜æ†¶é«”å¢é•·: ${(memoryIncrease / 1024 / 1024).toFixed(2)} MB`
                };
                
                log('âœ… è¨˜æ†¶é«”æ´©æ¼æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['memoryLeaks'] = { status: 'failed', error: error.message };
                log(`âŒ è¨˜æ†¶é«”æ´©æ¼æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ é‚Šç•Œæ¸¬è©¦ ============
        
        // æ¥µé™å€¼æ¸¬è©¦
        window.testExtremeValues = async function() {
            try {
                log('ğŸ¯ é–‹å§‹æ¥µé™å€¼æ¸¬è©¦...', 'info');
                testResults['extremeValues'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('extreme-test', 'INSTRUMENT', 'æ¥µé™å€¼æ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 10000 }, // å¢åŠ åˆ°10ç§’
                    { type: 'synth', name: 'Extreme Test Synth' },
                    'Extreme Test Clip'
                );
                
                // æ¸¬è©¦æ¥µç«¯MIDIå€¼
                const extremeTests = [
                    { note: 0, velocity: 1, duration: 1 },     // æœ€ä½éŸ³ç¬¦ï¼Œæœ€å°åŠ›åº¦ï¼Œæœ€çŸ­æ™‚é•·
                    { note: 127, velocity: 127, duration: 1 }, // æœ€é«˜éŸ³ç¬¦ï¼Œæœ€å¤§åŠ›åº¦
                    { note: 60, velocity: 100, duration: 2000 }, // é•·æ™‚é•· (2ç§’)
                    { note: 60, velocity: 0, duration: 500 },  // é›¶åŠ›åº¦
                ];
                
                for (let i = 0; i < extremeTests.length; i++) {
                    const test = extremeTests[i];
                    try {
                        const noteStart = i * 2500; // æ¯å€‹æ¸¬è©¦é–“éš”2.5ç§’
                        const noteEnd = noteStart + test.duration;
                        // ç¢ºä¿éŸ³ç¬¦åœ¨clipçš„10000msç¯„åœå…§
                        if (noteEnd <= 10000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                test.note,
                                test.velocity,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                            log(`ğŸ¯ æ¥µé™æ¸¬è©¦ ${i + 1}/4: MIDI ${test.note}, velocity ${test.velocity}, duration ${test.duration}ms`, 'debug');
                        } else {
                            log(`âš ï¸ æ¥µé™æ¸¬è©¦ ${i + 1} è·³é: éŸ³ç¬¦è¶…å‡ºclipç¯„åœ`, 'warning');
                        }
                    } catch (e) {
                        log(`âš ï¸ æ¥µé™æ¸¬è©¦ ${i + 1} å¤±æ•—: ${e.message}`, 'warning');
                    }
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                
                testResults['extremeValues'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['extremeValues'].startTime,
                    details: '4é …æ¥µé™å€¼æ¸¬è©¦å®Œæˆ'
                };
                
                log('âœ… æ¥µé™å€¼æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['extremeValues'] = { status: 'failed', error: error.message };
                log(`âŒ æ¥µé™å€¼æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // å¤§è¦æ¨¡æ¸¬è©¦
        window.testLargeScale = async function() {
            try {
                log('ğŸ“Š é–‹å§‹å¤§è¦æ¨¡æ¸¬è©¦ (100è»Œé“)...', 'info');
                testResults['largeScale'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const trackIds = [];
                
                // å‰µå»º100å€‹è»Œé“
                for (let i = 0; i < 100; i++) {
                    const trackId = await musicService.createTrack('large-scale', 'INSTRUMENT', `å¤§è¦æ¨¡æ¸¬è©¦è»Œé“ ${i + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 2000 },
                        { type: 'synth', name: `Large Scale Synth ${i}` },
                        `Large Scale Clip ${i}`
                    );
                    
                    // æ¯å€‹è»Œé“æ·»åŠ 10å€‹éŸ³ç¬¦
                    for (let j = 0; j < 10; j++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (j % 12),
                            100,
                            { startTime: j * 150, endTime: (j * 150) + 100 }
                        );
                    }
                    
                    trackIds.push(trackId);
                    
                    if ((i + 1) % 20 === 0) {
                        log(`ğŸ“Š å¤§è¦æ¨¡æ¸¬è©¦é€²åº¦: ${i + 1}/100 è»Œé“`, 'debug');
                    }
                }
                
                testResults['largeScale'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['largeScale'].startTime,
                    details: `æˆåŠŸå‰µå»º ${trackIds.length} å€‹è»Œé“ï¼Œå…± ${trackIds.length * 10} å€‹éŸ³ç¬¦`
                };
                
                log('âœ… å¤§è¦æ¨¡æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['largeScale'] = { status: 'failed', error: error.message };
                log(`âŒ å¤§è¦æ¨¡æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // é‚Šç•Œæƒ…æ³æ¸¬è©¦
        window.testEdgeCases = async function() {
            try {
                log('âš ï¸ é–‹å§‹é‚Šç•Œæƒ…æ³æ¸¬è©¦...', 'info');
                testResults['edgeCases'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                let casesPassed = 0;
                const totalCases = 5;
                
                // æƒ…æ³1: é›¶æ™‚é•·ç‰‡æ®µ
                try {
                    const trackId = await musicService.createTrack('edge-test', 'INSTRUMENT', 'é‚Šç•Œæ¸¬è©¦');
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 1000, endTime: 1000 }, // é›¶æ™‚é•·
                        { type: 'synth', name: 'Edge Test' },
                        'Edge Clip'
                    );
                    casesPassed++;
                    log('âœ… é›¶æ™‚é•·ç‰‡æ®µè™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ é›¶æ™‚é•·ç‰‡æ®µæ¸¬è©¦: ${e.message}`, 'warning');
                }
                
                // æƒ…æ³2: é‡ç–Šæ™‚é–“æ®µ
                try {
                    const trackId = await musicService.createTrack('overlap-test', 'INSTRUMENT', 'é‡ç–Šæ¸¬è©¦');
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 2000 },
                        { type: 'synth', name: 'Overlap Test' },
                        'Overlap Clip'
                    );
                    
                    // æ·»åŠ é‡ç–ŠéŸ³ç¬¦
                    await musicService.addMidiNote(trackId, clipId, 60, 100, { startTime: 0, endTime: 1000 });
                    await musicService.addMidiNote(trackId, clipId, 60, 100, { startTime: 500, endTime: 1500 });
                    casesPassed++;
                    log('âœ… é‡ç–ŠéŸ³ç¬¦è™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ é‡ç–ŠéŸ³ç¬¦æ¸¬è©¦: ${e.message}`, 'warning');
                }
                
                // æƒ…æ³3: è¶…å¯†é›†éŸ³ç¬¦ (æ¯æ¯«ç§’ä¸€å€‹)
                try {
                    const trackId = await musicService.createTrack('dense-test', 'INSTRUMENT', 'å¯†é›†æ¸¬è©¦');
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 100 },
                        { type: 'synth', name: 'Dense Test' },
                        'Dense Clip'
                    );
                    
                    // 100å€‹éŸ³ç¬¦åœ¨100æ¯«ç§’å…§
                    for (let i = 0; i < 100; i++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (i % 12),
                            100,
                            { startTime: i, endTime: i + 1 }
                        );
                    }
                    casesPassed++;
                    log('âœ… è¶…å¯†é›†éŸ³ç¬¦è™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ è¶…å¯†é›†éŸ³ç¬¦æ¸¬è©¦: ${e.message}`, 'warning');
                }
                
                // æƒ…æ³4: æ¥µé•·åç¨±
                try {
                    const longName = 'A'.repeat(1000); // 1000å­—ç¬¦çš„åç¨±
                    const trackId = await musicService.createTrack('long-name-test', 'INSTRUMENT', longName);
                    casesPassed++;
                    log('âœ… æ¥µé•·åç¨±è™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ æ¥µé•·åç¨±æ¸¬è©¦: ${e.message}`, 'warning');
                }
                
                // æƒ…æ³5: ç‰¹æ®Šå­—ç¬¦
                try {
                    const specialName = 'ğŸµğŸ¶â™ªâ™«ğŸ¼ğŸ¹ğŸ¥ğŸ¸ğŸºğŸ·ğŸ» ç‰¹æ®Šå­—ç¬¦æ¸¬è©¦ !@#$%^&*()';
                    const trackId = await musicService.createTrack('special-char-test', 'INSTRUMENT', specialName);
                    casesPassed++;
                    log('âœ… ç‰¹æ®Šå­—ç¬¦è™•ç†æ­£ç¢º', 'debug');
                } catch (e) {
                    log(`âš ï¸ ç‰¹æ®Šå­—ç¬¦æ¸¬è©¦: ${e.message}`, 'warning');
                }
                
                testResults['edgeCases'] = { 
                    status: casesPassed >= 3 ? 'passed' : 'failed', 
                    duration: Date.now() - testResults['edgeCases'].startTime,
                    details: `${casesPassed}/${totalCases} é‚Šç•Œæƒ…æ³æ¸¬è©¦é€šé`
                };
                
                log('âœ… é‚Šç•Œæƒ…æ³æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['edgeCases'] = { status: 'failed', error: error.message };
                log(`âŒ é‚Šç•Œæƒ…æ³æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ éŸ³æ¨‚æ€§æ¸¬è©¦ ============
        
        // å’Œè²æ¸¬è©¦
        window.testHarmony = async function() {
            try {
                log('ğŸ¹ é–‹å§‹å’Œè²æ¸¬è©¦...', 'info');
                testResults['harmony'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('harmony-test', 'INSTRUMENT', 'å’Œè²æ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 8000 },
                    { type: 'synth', name: 'Harmony Test Synth' },
                    'Harmony Test Clip'
                );
                
                // æ¸¬è©¦ä¸åŒå’Œå¼¦
                const chords = [
                    { name: 'Cå¤§ä¸‰å’Œå¼¦', notes: [60, 64, 67], start: 0 },
                    { name: 'Få¤§ä¸‰å’Œå¼¦', notes: [65, 69, 72], start: 1000 },
                    { name: 'Gå¤§ä¸‰å’Œå¼¦', notes: [67, 71, 74], start: 2000 },
                    { name: 'Amå°ä¸‰å’Œå¼¦', notes: [69, 72, 76], start: 3000 },
                    { name: 'Cå¤§ä¸ƒå’Œå¼¦', notes: [60, 64, 67, 71], start: 4000 },
                    { name: 'æ¸›ä¸ƒå’Œå¼¦', notes: [60, 63, 66, 69], start: 5000 },
                    { name: 'å¢ä¸‰å’Œå¼¦', notes: [60, 64, 68], start: 6000 },
                    { name: 'æ›å››å’Œå¼¦', notes: [60, 65, 67], start: 7000 },
                ];
                
                for (const chord of chords) {
                    for (let i = 0; i < chord.notes.length; i++) {
                        await musicService.addMidiNote(
                            testTrackId,
                            clipId,
                            chord.notes[i],
                            100,
                            { startTime: chord.start, endTime: chord.start + 800 }
                        );
                    }
                    log(`ğŸ¹ ${chord.name} (${chord.notes.join(',')})`, 'debug');
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['harmony'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['harmony'].startTime,
                    details: `${chords.length}ç¨®å’Œå¼¦é¡å‹æ¸¬è©¦å®Œæˆ`
                };
                
                log('âœ… å’Œè²æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['harmony'] = { status: 'failed', error: error.message };
                log(`âŒ å’Œè²æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ç¯€å¥æ¸¬è©¦
        window.testRhythm = async function() {
            try {
                log('ğŸ¥ é–‹å§‹ç¯€å¥æ¸¬è©¦...', 'info');
                testResults['rhythm'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('rhythm-test', 'INSTRUMENT', 'ç¯€å¥æ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 12000 }, // å¢åŠ åˆ°12ç§’ä»¥å®¹ç´æ‰€æœ‰ç¯€å¥æ¨¡å¼
                    { type: 'synth', name: 'Rhythm Test Synth' },
                    'Rhythm Test Clip'
                );
                
                // æ¸¬è©¦ä¸åŒç¯€å¥æ¨¡å¼
                const rhythms = [
                    { name: 'å››åˆ†éŸ³ç¬¦', pattern: [0, 500, 1000, 1500] },
                    { name: 'å…«åˆ†éŸ³ç¬¦', pattern: [0, 250, 500, 750, 1000, 1250, 1500, 1750] },
                    { name: 'ä¸‰é€£éŸ³', pattern: [0, 333, 667, 1000, 1333, 1667] },
                    { name: 'äº”é€£éŸ³', pattern: [0, 200, 400, 600, 800, 1000] },
                    { name: 'åˆ‡åˆ†éŸ³', pattern: [0, 250, 750, 1250, 1750] },
                ];
                
                let currentTime = 0;
                for (const rhythm of rhythms) {
                    for (const offset of rhythm.pattern) {
                        const noteStart = currentTime + offset;
                        const noteEnd = noteStart + 100;
                        // ç¢ºä¿éŸ³ç¬¦åœ¨clipçš„12000msç¯„åœå…§
                        if (noteEnd <= 12000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                60,
                                100,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                        }
                    }
                    log(`ğŸ¥ ${rhythm.name} ç¯€å¥æ¨¡å¼`, 'debug');
                    currentTime += 2000; // æ¯å€‹æ¨¡å¼é–“éš”2ç§’
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['rhythm'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['rhythm'].startTime,
                    details: `${rhythms.length}ç¨®ç¯€å¥æ¨¡å¼æ¸¬è©¦å®Œæˆ`
                };
                
                log('âœ… ç¯€å¥æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['rhythm'] = { status: 'failed', error: error.message };
                log(`âŒ ç¯€å¥æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // éŸ³éšæ¸¬è©¦
        window.testScales = async function() {
            try {
                log('ğŸ¶ é–‹å§‹éŸ³éšæ¸¬è©¦...', 'info');
                testResults['scales'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('scales-test', 'INSTRUMENT', 'éŸ³éšæ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 15000 }, // å¢åŠ åˆ°15ç§’ä»¥å®¹ç´æ‰€æœ‰éŸ³éš
                    { type: 'synth', name: 'Scales Test Synth' },
                    'Scales Test Clip'
                );
                
                // æ¸¬è©¦ä¸åŒéŸ³éš
                const scales = [
                    { name: 'Cå¤§èª¿', intervals: [0, 2, 4, 5, 7, 9, 11, 12] },
                    { name: 'Aå°èª¿', intervals: [0, 2, 3, 5, 7, 8, 10, 12] },
                    { name: 'äº”è²éŸ³éš', intervals: [0, 2, 4, 7, 9, 12] },
                    { name: 'å¸ƒé­¯æ–¯éŸ³éš', intervals: [0, 3, 5, 6, 7, 10, 12] },
                    { name: 'å…¨éŸ³éš', intervals: [0, 2, 4, 6, 8, 10, 12] },
                    { name: 'åŠéŸ³éš', intervals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] },
                ];
                
                let currentTime = 0;
                for (const scale of scales) {
                    for (let i = 0; i < scale.intervals.length; i++) {
                        const midiNote = 60 + scale.intervals[i]; // å¾C4é–‹å§‹
                        const noteStart = currentTime + (i * 200);
                        const noteEnd = noteStart + 150;
                        // ç¢ºä¿éŸ³ç¬¦åœ¨clipçš„15000msç¯„åœå…§
                        if (noteEnd <= 15000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                midiNote,
                                100,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                        }
                    }
                    log(`ğŸ¶ ${scale.name} (${scale.intervals.length}éŸ³)`, 'debug');
                    currentTime += scale.intervals.length * 200 + 500; // éŸ³éšé–“é–“éš”
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['scales'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['scales'].startTime,
                    details: `${scales.length}ç¨®éŸ³éšé¡å‹æ¸¬è©¦å®Œæˆ`
                };
                
                log('âœ… éŸ³éšæ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['scales'] = { status: 'failed', error: error.message };
                log(`âŒ éŸ³éšæ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ ç”¨æˆ¶é«”é©—æ¸¬è©¦ ============
        
        // éŸ¿æ‡‰æ€§æ¸¬è©¦
        window.testResponsiveness = async function() {
            try {
                log('âš¡ é–‹å§‹éŸ¿æ‡‰æ€§æ¸¬è©¦...', 'info');
                testResults['responsiveness'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const responseTimes = [];
                
                // æ¸¬è©¦10æ¬¡å¿«é€Ÿæ“ä½œçš„éŸ¿æ‡‰æ™‚é–“
                for (let i = 0; i < 10; i++) {
                    const opStart = performance.now();
                    
                    const trackId = await musicService.createTrack('response-test', 'INSTRUMENT', `éŸ¿æ‡‰æ¸¬è©¦ ${i}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 1000 },
                        { type: 'synth', name: 'Response Test' },
                        'Response Clip'
                    );
                    await musicService.addMidiNote(trackId, clipId, 60, 100, { startTime: 0, endTime: 500 });
                    
                    const opEnd = performance.now();
                    const responseTime = opEnd - opStart;
                    responseTimes.push(responseTime);
                    
                    log(`âš¡ æ“ä½œ ${i + 1}/10: ${responseTime.toFixed(2)}ms`, 'debug');
                }
                
                const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
                const maxResponseTime = Math.max(...responseTimes);
                
                testResults['responsiveness'] = { 
                    status: avgResponseTime < 500 ? 'passed' : 'warning', 
                    duration: Date.now() - testResults['responsiveness'].startTime,
                    details: `å¹³å‡éŸ¿æ‡‰: ${avgResponseTime.toFixed(2)}ms, æœ€å¤§: ${maxResponseTime.toFixed(2)}ms`
                };
                
                log('âœ… éŸ¿æ‡‰æ€§æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['responsiveness'] = { status: 'failed', error: error.message };
                log(`âŒ éŸ¿æ‡‰æ€§æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // éŸ³è³ªæ¸¬è©¦
        window.testAudioQuality = async function() {
            try {
                log('ğŸ”Š é–‹å§‹éŸ³è³ªæ¸¬è©¦...', 'info');
                testResults['audioQuality'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // å‰µå»ºå¤šè»Œé“æ··éŸ³æ¸¬è©¦
                const trackIds = [];
                
                // å‰µå»º3å€‹ä¸åŒéŸ³åŸŸçš„è»Œé“
                const ranges = [
                    { name: 'ä½éŸ³', base: 36, count: 4 },  // C2-E2
                    { name: 'ä¸­éŸ³', base: 60, count: 4 },  // C4-E4  
                    { name: 'é«˜éŸ³', base: 84, count: 4 },  // C6-E6
                ];
                
                for (const range of ranges) {
                    const trackId = await musicService.createTrack('audio-quality', 'INSTRUMENT', `éŸ³è³ªæ¸¬è©¦_${range.name}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 3000 },
                        { type: 'synth', name: `Quality Test ${range.name}` },
                        `Quality Clip ${range.name}`
                    );
                    
                    // æ¯å€‹éŸ³åŸŸæ·»åŠ å’Œå¼¦
                    for (let i = 0; i < range.count; i++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            range.base + (i * 2), // å¤§äºŒåº¦é–“éš”
                            100,
                            { startTime: 0, endTime: 2500 }
                        );
                    }
                    
                    await musicService.addTrackToAdapter(trackId);
                    trackIds.push(trackId);
                    log(`ğŸ”Š ${range.name}éŸ³åŸŸè»Œé“å‰µå»ºå®Œæˆ`, 'debug');
                }
                
                // æ¸¬è©¦åŒæ™‚æ’­æ”¾
                log('ğŸ”Š æ¸¬è©¦å¤šè»Œé“æ··éŸ³...', 'debug');
                await musicService.playAllTracks();
                
                testResults['audioQuality'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['audioQuality'].startTime,
                    details: `${trackIds.length}è»Œé“éŸ³è³ªæ¸¬è©¦å®Œæˆ`
                };
                
                log('âœ… éŸ³è³ªæ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['audioQuality'] = { status: 'failed', error: error.message };
                log(`âŒ éŸ³è³ªæ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // å¯¦æ™‚ç·¨è¼¯æ¸¬è©¦
        window.testRealTimeEditing = async function() {
            try {
                log('âœï¸ é–‹å§‹å¯¦æ™‚ç·¨è¼¯æ¸¬è©¦...', 'info');
                testResults['realTimeEditing'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('realtime-test', 'INSTRUMENT', 'å¯¦æ™‚ç·¨è¼¯æ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 5000 },
                    { type: 'synth', name: 'Realtime Test Synth' },
                    'Realtime Test Clip'
                );
                
                await musicService.addTrackToAdapter(testTrackId);
                
                // åˆå§‹éŸ³ç¬¦
                const noteIds = [];
                for (let i = 0; i < 5; i++) {
                    const noteId = await musicService.addMidiNote(
                        testTrackId,
                        clipId,
                        60 + i,
                        100,
                        { startTime: i * 800, endTime: (i * 800) + 600 }
                    );
                    noteIds.push(noteId);
                }
                
                log('âœï¸ é–‹å§‹æ’­æ”¾ä¸¦å¯¦æ™‚æ·»åŠ éŸ³ç¬¦...', 'debug');
                await musicService.playMidiClip(testTrackId, clipId);
                
                // æ’­æ”¾æœŸé–“å‹•æ…‹æ·»åŠ éŸ³ç¬¦ (æ¨¡æ“¬å¯¦æ™‚ç·¨è¼¯)
                setTimeout(async () => {
                    try {
                        for (let i = 0; i < 3; i++) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                65 + i,
                                80,
                                { startTime: 2000 + (i * 500), endTime: 2000 + (i * 500) + 400 }
                            );
                            log(`âœï¸ å¯¦æ™‚æ·»åŠ éŸ³ç¬¦ ${i + 1}/3`, 'debug');
                        }
                    } catch (e) {
                        log(`âš ï¸ å¯¦æ™‚ç·¨è¼¯éç¨‹ä¸­å‡ºç¾å•é¡Œ: ${e.message}`, 'warning');
                    }
                }, 1000);
                
                testResults['realTimeEditing'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['realTimeEditing'].startTime,
                    details: 'å¯¦æ™‚ç·¨è¼¯åŠŸèƒ½æ¸¬è©¦å®Œæˆ'
                };
                
                log('âœ… å¯¦æ™‚ç·¨è¼¯æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['realTimeEditing'] = { status: 'failed', error: error.message };
                log(`âŒ å¯¦æ™‚ç·¨è¼¯æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ æ•´åˆæ¸¬è©¦ ============
        
        // è·¨åŠŸèƒ½æ¸¬è©¦
        window.testCrossFeatures = async function() {
            try {
                log('ğŸ¯ é–‹å§‹è·¨åŠŸèƒ½æ¸¬è©¦...', 'info');
                testResults['crossFeatures'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // æ¸¬è©¦æ’­æ”¾ä¸­ç·¨è¼¯
                const trackId = await musicService.createTrack('cross-test', 'INSTRUMENT', 'è·¨åŠŸèƒ½æ¸¬è©¦');
                const clipId = await musicService.createMidiClip(
                    trackId,
                    { startTime: 0, endTime: 6000 },
                    { type: 'synth', name: 'Cross Feature Test' },
                    'Cross Feature Clip'
                );
                
                // æ·»åŠ åˆå§‹éŸ³ç¬¦
                for (let i = 0; i < 8; i++) {
                    await musicService.addMidiNote(
                        trackId,
                        clipId,
                        60 + (i % 7),
                        100,
                        { startTime: i * 500, endTime: (i * 500) + 400 }
                    );
                }
                
                await musicService.addTrackToAdapter(trackId);
                
                // é–‹å§‹æ’­æ”¾
                await musicService.playMidiClip(trackId, clipId);
                log('ğŸ¯ é–‹å§‹æ’­æ”¾ä¸¦æ¸¬è©¦ä¸¦ç™¼æ“ä½œ...', 'debug');
                
                // ä¸¦ç™¼åŸ·è¡Œå¤šé …æ“ä½œ
                const operations = [];
                
                // æ“ä½œ1: å‰µå»ºæ–°è»Œé“
                operations.push(
                    musicService.createTrack('concurrent', 'INSTRUMENT', 'ä¸¦ç™¼æ¸¬è©¦è»Œé“')
                );
                
                // æ“ä½œ2: èª¿è©¦åŠŸèƒ½
                operations.push(
                    musicService.debugAdapterState()
                );
                
                // æ“ä½œ3: æ·»åŠ æ›´å¤šéŸ³ç¬¦
                operations.push(
                    musicService.addMidiNote(
                        trackId,
                        clipId,
                        72,
                        120,
                        { startTime: 4000, endTime: 4500 }
                    )
                );
                
                // ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆ
                await Promise.all(operations);
                
                testResults['crossFeatures'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['crossFeatures'].startTime,
                    details: 'æ’­æ”¾ä¸­ä¸¦ç™¼ç·¨è¼¯æ¸¬è©¦å®Œæˆ'
                };
                
                log('âœ… è·¨åŠŸèƒ½æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['crossFeatures'] = { status: 'failed', error: error.message };
                log(`âŒ è·¨åŠŸèƒ½æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // æ•¸æ“šæŒä¹…åŒ–æ¸¬è©¦
        window.testDataPersistence = async function() {
            try {
                log('ğŸ’¾ é–‹å§‹æ•¸æ“šæŒä¹…åŒ–æ¸¬è©¦...', 'info');
                testResults['dataPersistence'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // å‰µå»ºè¤‡é›œçš„éŸ³æ¨‚çµæ§‹
                const trackData = [];
                
                for (let i = 0; i < 3; i++) {
                    const trackId = await musicService.createTrack('persist-test', 'INSTRUMENT', `æŒä¹…åŒ–æ¸¬è©¦è»Œé“ ${i + 1}`);
                    const clipIds = [];
                    
                    // æ¯å€‹è»Œé“å‰µå»º2å€‹ç‰‡æ®µ
                    for (let j = 0; j < 2; j++) {
                        const clipId = await musicService.createMidiClip(
                            trackId,
                            { startTime: 0, endTime: 1500 }, // ä½¿ç”¨å›ºå®šçš„0-1500msç¯„åœ
                            { type: 'synth', name: `Persist Synth ${i}-${j}` },
                            `Persist Clip ${i}-${j}`
                        );
                        
                        // æ¯å€‹ç‰‡æ®µæ·»åŠ éŸ³ç¬¦ - ç¢ºä¿éŸ³ç¬¦åœ¨clipç¯„åœå…§
                        for (let k = 0; k < 5; k++) {
                            const noteStart = k * 200;
                            const noteEnd = noteStart + 150;
                            // ç¢ºä¿éŸ³ç¬¦åœ¨ç‰‡æ®µçš„1500msç¯„åœå…§
                            if (noteEnd <= 1500) {
                                await musicService.addMidiNote(
                                    trackId,
                                    clipId,
                                    60 + (i * 5) + k,
                                    100,
                                    { startTime: noteStart, endTime: noteEnd }
                                );
                            }
                        }
                        
                        clipIds.push(clipId);
                    }
                    
                    trackData.push({ trackId, clipIds });
                    await musicService.addTrackToAdapter(trackId);
                }
                
                log('ğŸ’¾ æ¸¬è©¦æ•¸æ“šçµæ§‹å‰µå»ºå®Œæˆ', 'debug');
                
                // æ¸¬è©¦èª¿è©¦åŠŸèƒ½ï¼ˆé–“æ¥æ¸¬è©¦æ•¸æ“šæŒä¹…æ€§ï¼‰
                await musicService.debugAdapterState();
                
                for (const track of trackData) {
                    await musicService.debugAudioChain(track.trackId);
                }
                
                testResults['dataPersistence'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['dataPersistence'].startTime,
                    details: `${trackData.length}è»Œé“æ•¸æ“šæŒä¹…åŒ–æ¸¬è©¦å®Œæˆ`
                };
                
                log('âœ… æ•¸æ“šæŒä¹…åŒ–æ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['dataPersistence'] = { status: 'failed', error: error.message };
                log(`âŒ æ•¸æ“šæŒä¹…åŒ–æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // å®Œæ•´å·¥ä½œæµæ¸¬è©¦
        window.testFullWorkflow = async function() {
            try {
                log('ğŸ”„ é–‹å§‹å®Œæ•´å·¥ä½œæµæ¸¬è©¦...', 'info');
                testResults['fullWorkflow'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // æ¨¡æ“¬å®Œæ•´çš„éŸ³æ¨‚è£½ä½œæµç¨‹
                
                // 1. å‰µå»ºé …ç›®çµæ§‹
                log('ğŸ”„ æ­¥é©Ÿ1: å‰µå»ºé …ç›®çµæ§‹...', 'debug');
                const tracks = [];
                
                const trackTypes = [
                    { name: 'é¼“çµ„è»Œé“', noteRange: [36, 42] },
                    { name: 'è²æ–¯è»Œé“', noteRange: [28, 48] },
                    { name: 'å’Œå¼¦è»Œé“', noteRange: [48, 72] },
                    { name: 'ä¸»æ—‹å¾‹è»Œé“', noteRange: [60, 84] },
                ];
                
                for (const trackType of trackTypes) {
                    const trackId = await musicService.createTrack('workflow-test', 'INSTRUMENT', trackType.name);
                    await musicService.addTrackToAdapter(trackId);
                    tracks.push({ trackId, ...trackType });
                }
                
                // 2. å¡«å……éŸ³æ¨‚å…§å®¹
                log('ğŸ”„ æ­¥é©Ÿ2: å¡«å……éŸ³æ¨‚å…§å®¹...', 'debug');
                for (const track of tracks) {
                    const clipId = await musicService.createMidiClip(
                        track.trackId,
                        { startTime: 0, endTime: 8000 },
                        { type: 'synth', name: `${track.name} Synth` },
                        `${track.name} Clip`
                    );
                    
                    // æ ¹æ“šè»Œé“é¡å‹æ·»åŠ é©ç•¶çš„éŸ³ç¬¦
                    const noteCount = track.name.includes('é¼“çµ„') ? 16 : 8;
                    for (let i = 0; i < noteCount; i++) {
                        const noteRange = track.noteRange[1] - track.noteRange[0];
                        const note = track.noteRange[0] + (i % noteRange);
                        const startTime = (i * 8000) / noteCount;
                        
                        await musicService.addMidiNote(
                            track.trackId,
                            clipId,
                            note,
                            100,
                            { startTime, endTime: startTime + 200 }
                        );
                    }
                }
                
                // 3. æ¸¬è©¦æ’­æ”¾
                log('ğŸ”„ æ­¥é©Ÿ3: æ¸¬è©¦å®Œæ•´æ’­æ”¾...', 'debug');
                await musicService.playAllTracks();
                
                // 4. æ¸¬è©¦åœæ­¢
                setTimeout(async () => {
                    log('ğŸ”„ æ­¥é©Ÿ4: æ¸¬è©¦åœæ­¢åŠŸèƒ½...', 'debug');
                    await musicService.stopAllTracks();
                }, 3000);
                
                // 5. æ¸¬è©¦ç‹€æ…‹æª¢æŸ¥
                log('ğŸ”„ æ­¥é©Ÿ5: æª¢æŸ¥ç³»çµ±ç‹€æ…‹...', 'debug');
                await musicService.debugAdapterState();
                
                testResults['fullWorkflow'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['fullWorkflow'].startTime,
                    details: `å®Œæ•´å·¥ä½œæµç¨‹ (${tracks.length}è»Œé“) æ¸¬è©¦å®Œæˆ`
                };
                
                log('âœ… å®Œæ•´å·¥ä½œæµæ¸¬è©¦å®Œæˆ', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['fullWorkflow'] = { status: 'failed', error: error.message };
                log(`âŒ å®Œæ•´å·¥ä½œæµæ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ æ¸¬è©¦æ§åˆ¶åŠŸèƒ½ ============
        
        // é‹è¡Œå…¨éƒ¨æ¸¬è©¦
        window.runAllTests = async function() {
            try {
                log('ğŸš€ é–‹å§‹é‹è¡Œå…¨éƒ¨æ¸¬è©¦...', 'info');
                isTestRunning = true;
                testAbortController = new AbortController();
                
                // æ¸…ç©ºä¹‹å‰çš„çµæœ
                testResults = {};
                updateTestSummary();
                
                const testFunctions = [
                    // åŠŸèƒ½æ€§æ¸¬è©¦
                    testMidiAccuracy,
                    testTrackOperations, 
                    testClipOperations,
                    // ç©©å®šæ€§æ¸¬è©¦
                    testDurability,
                    testExceptionHandling,
                    testMemoryLeaks,
                    // é‚Šç•Œæ¸¬è©¦
                    testExtremeValues,
                    testLargeScale,
                    testEdgeCases,
                    // éŸ³æ¨‚æ€§æ¸¬è©¦
                    testHarmony,
                    testRhythm,
                    testScales,
                    // ç”¨æˆ¶é«”é©—æ¸¬è©¦
                    testResponsiveness,
                    testAudioQuality,
                    testRealTimeEditing,
                    // æ•´åˆæ¸¬è©¦
                    testCrossFeatures,
                    testDataPersistence,
                    testFullWorkflow,
                ];
                
                log(`ğŸ“Š å°‡ä¾åºåŸ·è¡Œ ${testFunctions.length} å€‹æ¸¬è©¦...`, 'info');
                
                for (let i = 0; i < testFunctions.length; i++) {
                    if (testAbortController.signal.aborted) {
                        log('â¹ï¸ æ¸¬è©¦è¢«ç”¨æˆ¶ä¸­æ–·', 'warning');
                        break;
                    }
                    
                    log(`ğŸ”„ åŸ·è¡Œæ¸¬è©¦ ${i + 1}/${testFunctions.length}...`, 'info');
                    await testFunctions[i]();
                    
                    // æ¸¬è©¦é–“çŸ­æš«é–“éš”
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // ç¸½çµæ¸¬è©¦çµæœ
                const total = Object.keys(testResults).length;
                const passed = Object.values(testResults).filter(r => r.status === 'passed').length;
                const failed = Object.values(testResults).filter(r => r.status === 'failed').length;
                const warnings = Object.values(testResults).filter(r => r.status === 'warning').length;
                
                log('ğŸ‰ å…¨éƒ¨æ¸¬è©¦å®Œæˆï¼', 'success');
                log(`ğŸ“Š æ¸¬è©¦ç¸½çµ: ${total}é …æ¸¬è©¦ | âœ…${passed}é€šé | âŒ${failed}å¤±æ•— | âš ï¸${warnings}è­¦å‘Š`, 'info');
                
                isTestRunning = false;
                
            } catch (error) {
                log(`âŒ æ¸¬è©¦é‹è¡Œå¤±æ•—: ${error.message}`, 'error');
                isTestRunning = false;
            }
        };
        
        // åœæ­¢æ‰€æœ‰æ¸¬è©¦
        window.stopAllTests = function() {
            if (isTestRunning && testAbortController) {
                testAbortController.abort();
                log('â¹ï¸ æ­£åœ¨åœæ­¢æ‰€æœ‰æ¸¬è©¦...', 'warning');
                isTestRunning = false;
            }
        };
        
        // é‹è¡Œé¸ä¸­æ¸¬è©¦ (ç°¡åŒ–å¯¦ç¾)
        window.runSelectedTests = async function() {
            log('âœ… é‹è¡Œé¸ä¸­æ¸¬è©¦åŠŸèƒ½ (ç¤ºä¾‹å¯¦ç¾)', 'info');
            // é€™è£¡å¯ä»¥å¯¦ç¾åŸºæ–¼ç”¨æˆ¶é¸æ“‡çš„æ¸¬è©¦é‹è¡Œé‚è¼¯
            await testMidiAccuracy();
            await testResponsiveness();
            log('âœ… é¸ä¸­æ¸¬è©¦å®Œæˆ', 'success');
        };
    </script>
</body>
</html> 