<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéµ MIDI Clip Êí≠ÊîæÈ©óË≠â - Â∞èÊòüÊòü‰∏âËÅ≤ÈÉ®ÂíåËÅ≤ÁâàÊú¨</title>
    <!-- Tone.js CDN -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #2d3748, #4a5568);
            border-radius: 15px;
            border: 2px solid #4a5568;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }
        
        .header p {
            font-size: 1.2rem;
            color: #e2e8f0;
            margin-bottom: 20px;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px 25px;
            background: #2d3748;
            border-radius: 10px;
            border: 1px solid #4a5568;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-loading { background: rgba(245, 158, 11, 0.2); border: 1px solid #f59e0b; }
        .status-ready { background: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; }
        .status-error { background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; }
        .status-playing { background: rgba(59, 130, 246, 0.2); border: 1px solid #3b82f6; }
        
        .main-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-section {
            background: #2d3748;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #4a5568;
        }
        
        .control-section h3 {
            color: #ffd700;
            font-size: 1.3rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin: 5px;
            display: inline-block;
        }
        
        .btn:hover { transform: translateY(-2px); opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .btn-primary { background: #3182ce; color: white; }
        .btn-success { background: #38a169; color: white; }
        .btn-warning { background: #d69e2e; color: white; }
        .btn-danger { background: #e53e3e; color: white; }
        .btn-info { background: #00b4d8; color: white; }
        .btn-secondary { background: #718096; color: white; }
        
        .btn-large {
            font-size: 18px;
            padding: 20px 30px;
            min-width: 250px;
        }
        
        .track-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .track-card {
            background: #2d3748;
            border-radius: 12px;
            padding: 25px;
            border: 2px solid #4a5568;
            transition: all 0.3s;
        }
        
        .track-card:hover {
            border-color: #ffd700;
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.2);
        }
        
        .track-card.active {
            border-color: #ffd700;
            background: #374151;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .track-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #ffd700;
        }
        
        .track-range {
            font-size: 12px;
            color: #a0aec0;
            background: #4a5568;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .track-info {
            margin-bottom: 15px;
            font-size: 14px;
            color: #e2e8f0;
        }
        
        .track-info div {
            margin-bottom: 5px;
        }
        
        .note-sequence {
            background: #1a202c;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #4a5568;
        }
        
        .note-sequence h5 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .notes-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .note-item {
            background: #4a5568;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .note-item.high { background: #e53e3e; }
        .note-item.mid { background: #38a169; }
        .note-item.low { background: #3182ce; }
        
        .track-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .console {
            background: #0a0a0a;
            border-radius: 10px;
            border: 2px solid #4a5568;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .console-header {
            background: #1a202c;
            padding: 15px 20px;
            border-bottom: 1px solid #4a5568;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 10px 10px 0 0;
        }
        
        .console-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .log-filters {
            display: flex;
            gap: 5px;
            margin-right: 10px;
        }
        
        .log-filters .btn {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .log-entry.hidden {
            display: none;
        }
        
        .error-summary {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a202c;
            border: 2px solid #e53e3e;
            border-radius: 10px;
            padding: 20px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .error-summary-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
        
        .console-title {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .console-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .log-entry {
            margin-bottom: 6px;
            display: flex;
            align-items: flex-start;
        }
        
        .log-time {
            color: #718096;
            margin-right: 15px;
            min-width: 90px;
            font-size: 11px;
        }
        
        .log-success { color: #68d391; }
        .log-error { color: #fc8181; }
        .log-warning { color: #f6e05e; }
        .log-info { color: #63b3ed; }
        .log-debug { color: #a0aec0; }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffd700;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #4a5568;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-item {
            background: #2d3748;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #4a5568;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #a0aec0;
        }
        
        /* Ê∏¨Ë©¶ÁµÑÊ®£Âºè */
        .test-groups {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .test-group {
            border: 1px solid #4a5568;
            border-radius: 6px;
            background: #1a202c;
        }
        
        .test-group-header {
            width: 100%;
            padding: 8px 12px;
            background: transparent;
            border: none;
            color: #ffd700;
            font-weight: 600;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .test-group-header:hover {
            background: #2d3748;
        }
        
        .test-group-content {
            padding: 8px 12px;
            display: none;
            flex-wrap: wrap;
            gap: 6px;
            border-top: 1px solid #4a5568;
            background: #2d3748;
        }
        
        .test-group-content.expanded {
            display: flex;
        }
        
        .btn-sm {
            padding: 6px 10px;
            font-size: 11px;
            min-width: auto;
        }
        
        .test-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .test-results {
            background: #1a202c;
            border-radius: 4px;
            padding: 8px;
            border: 1px solid #4a5568;
        }
        
        .log-filters .btn.active {
            background: #3182ce !important;
            border-color: #3182ce !important;
            box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üéµ MIDI Clip Êí≠ÊîæÈ©óË≠â</h1>
            <p>Â∞èÊòüÊòüÊóãÂæã - ‰∏âËÅ≤ÈÉ®ÂíåËÅ≤ÁâàÊú¨Ê∏¨Ë©¶ (‰∏ªÊóãÂæã + ÂíåËÅ≤ + ‰ΩéÈü≥)</p>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="trackCount">0</div>
                    <div class="stat-label">ËªåÈÅìÊï∏Èáè</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="clipCount">0</div>
                    <div class="stat-label">MIDI ÁâáÊÆµ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="noteCount">0</div>
                    <div class="stat-label">Èü≥Á¨¶Á∏ΩÊï∏</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="playbackStatus">ÂæÖÊ©ü</div>
                    <div class="stat-label">Êí≠ÊîæÁãÄÊÖã</div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span>üéµ Music BC ÁãÄÊÖã:</span>
                <div class="status-indicator status-loading" id="systemStatus">
                    <span class="loading-spinner"></span> ËºâÂÖ•‰∏≠...
                </div>
            </div>
            <div class="status-item">
                <span>üîä Èü≥È†ªÁãÄÊÖã:</span>
                <div class="status-indicator status-error" id="audioStatus">
                    üîá Êú™ÂàùÂßãÂåñ
                </div>
            </div>
            <div class="status-item">
                <span>‚è±Ô∏è Áï∂ÂâçÊôÇÈñì:</span>
                <span id="currentTime">00:00:00</span>
            </div>
        </div>

        <!-- Main Controls -->
        <div class="main-controls">
            <div class="control-section">
                <h3>üéõÔ∏è Á≥ªÁµ±ÊéßÂà∂</h3>
                <button class="btn btn-primary btn-large" onclick="initializeSystem()" id="initBtn">
                    üöÄ ÂàùÂßãÂåñÁ≥ªÁµ±
                </button>
                <button class="btn btn-success btn-large" onclick="createTwinkleTracks()" id="createBtn" disabled>
                    üåü ÂâµÂª∫Â∞èÊòüÊòüËªåÈÅì
                </button>
                <button class="btn btn-warning" onclick="clearAllTracks()" id="clearBtn" disabled>
                    üóëÔ∏è Ê∏ÖÈô§ÊâÄÊúâËªåÈÅì
                </button>
            </div>

            <div class="control-section">
                <h3>üéÆ Êí≠ÊîæÊéßÂà∂</h3>
                <button class="btn btn-success btn-large" onclick="playAllTracks()" id="playAllBtn" disabled>
                    ‚ñ∂Ô∏è Êí≠ÊîæÂÖ®ÈÉ®Ôºà‰∏âÈü≥ÂüüÔºâ
                </button>
                <button class="btn btn-danger btn-large" onclick="stopAllTracks()" id="stopBtn" disabled>
                    ‚èπÔ∏è ÂÅúÊ≠¢Êí≠Êîæ
                </button>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="control-section">
                <h3>üîß Ê∏¨Ë©¶ÊéßÂà∂</h3>
                <button class="btn btn-info" onclick="playSequential()" id="sequentialBtn" disabled>
                    üéµ ‰æùÂ∫èÊí≠ÊîæÔºàÈ´ò‚Üí‰∏≠‚Üí‰ΩéÔºâ
                </button>
                <button class="btn btn-secondary" onclick="testSingleTrack('high')" id="testHighBtn" disabled>
                    üî¥ Ê∏¨Ë©¶È´òÈü≥ËªåÈÅì
                </button>
                <button class="btn btn-secondary" onclick="testSingleTrack('mid')" id="testMidBtn" disabled>
                    üü¢ Ê∏¨Ë©¶‰∏≠Èü≥ËªåÈÅì
                </button>
                <button class="btn btn-secondary" onclick="testSingleTrack('low')" id="testLowBtn" disabled>
                    üîµ Ê∏¨Ë©¶‰ΩéÈü≥ËªåÈÅì
                </button>
            </div>

            <div class="control-section">
                <h3>‚ö° ÊÄßËÉΩÊ∏¨Ë©¶</h3>
                <button class="btn btn-warning" onclick="performanceTestBasic()" id="perfTestBasicBtn" disabled>
                    üöÄ Âü∫Á§éÊÄßËÉΩÊ∏¨Ë©¶
                </button>
                <button class="btn btn-danger" onclick="performanceTestHeavy()" id="perfTestHeavyBtn" disabled>
                    üî• ÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶
                </button>
                <button class="btn btn-info" onclick="performanceTestMemory()" id="perfTestMemoryBtn" disabled>
                    üíæ Ë®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶
                </button>
                <button class="btn btn-secondary" onclick="performanceTestConcurrency()" id="perfTestConcurrencyBtn" disabled>
                    üîÑ ‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶
                </button>
                <div style="margin-top: 10px; font-size: 12px; color: #a0aec0;">
                    <div id="perfResults">ÊÄßËÉΩÊ∏¨Ë©¶ÁµêÊûúÂ∞áÈ°ØÁ§∫Âú®ÈÄôË£°</div>
                </div>
            </div>

            <div class="control-section">
                <h3>üß™ ÂÖ®Èù¢Ê∏¨Ë©¶Â•ó‰ª∂</h3>
                <div class="test-groups">
                    <!-- ÂäüËÉΩÊÄßÊ∏¨Ë©¶ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('functional')">
                            üéØ ÂäüËÉΩÊÄßÊ∏¨Ë©¶ <span id="functional-icon">‚ñº</span>
                        </button>
                        <div class="test-group-content" id="functional-tests">
                            <button class="btn btn-info btn-sm" onclick="testMidiAccuracy()" disabled>üéµ MIDIÁ≤æÁ¢∫ÊÄß</button>
                            <button class="btn btn-info btn-sm" onclick="testTrackOperations()" disabled>üéõÔ∏è ËªåÈÅìÊìç‰Ωú</button>
                            <button class="btn btn-info btn-sm" onclick="testClipOperations()" disabled>‚úÇÔ∏è ÁâáÊÆµÊìç‰Ωú</button>
                        </div>
                    </div>

                    <!-- Á©©ÂÆöÊÄßÊ∏¨Ë©¶ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('stability')">
                            üõ°Ô∏è Á©©ÂÆöÊÄßÊ∏¨Ë©¶ <span id="stability-icon">‚ñº</span>
                        </button>
                        <div class="test-group-content" id="stability-tests">
                            <button class="btn btn-warning btn-sm" onclick="testDurability()" disabled>‚è±Ô∏è ËÄê‰πÖÊÄßÊ∏¨Ë©¶</button>
                            <button class="btn btn-warning btn-sm" onclick="testExceptionHandling()" disabled>üö® Áï∞Â∏∏ËôïÁêÜ</button>
                            <button class="btn btn-warning btn-sm" onclick="testMemoryLeaks()" disabled>üîç Ë®òÊÜ∂È´îÊ¥©Êºè</button>
                        </div>
                    </div>

                    <!-- ÈÇäÁïåÊ∏¨Ë©¶ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('edge')">
                            üî¨ ÈÇäÁïåÊ∏¨Ë©¶ <span id="edge-icon">‚ñº</span>
                        </button>
                        <div class="test-group-content" id="edge-tests">
                            <button class="btn btn-danger btn-sm" onclick="testExtremeValues()" disabled>üéØ Ê•µÈôêÂÄºÊ∏¨Ë©¶</button>
                            <button class="btn btn-danger btn-sm" onclick="testLargeScale()" disabled>üìä Â§ßË¶èÊ®°Ê∏¨Ë©¶</button>
                            <button class="btn btn-danger btn-sm" onclick="testEdgeCases()" disabled>‚ö†Ô∏è ÈÇäÁïåÊÉÖÊ≥Å</button>
                        </div>
                    </div>

                    <!-- Èü≥Ê®ÇÊÄßÊ∏¨Ë©¶ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('musical')">
                            üéº Èü≥Ê®ÇÊÄßÊ∏¨Ë©¶ <span id="musical-icon">‚ñº</span>
                        </button>
                        <div class="test-group-content" id="musical-tests">
                            <button class="btn btn-success btn-sm" onclick="testHarmony()" disabled>üéπ ÂíåËÅ≤Ê∏¨Ë©¶</button>
                            <button class="btn btn-success btn-sm" onclick="testRhythm()" disabled>ü•Å ÁØÄÂ•èÊ∏¨Ë©¶</button>
                            <button class="btn btn-success btn-sm" onclick="testScales()" disabled>üé∂ Èü≥ÈöéÊ∏¨Ë©¶</button>
                        </div>
                    </div>

                    <!-- Áî®Êà∂È´îÈ©óÊ∏¨Ë©¶ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('ux')">
                            üé® È´îÈ©óÊ∏¨Ë©¶ <span id="ux-icon">‚ñº</span>
                        </button>
                        <div class="test-group-content" id="ux-tests">
                            <button class="btn btn-primary btn-sm" onclick="testResponsiveness()" disabled>‚ö° ÈüøÊáâÊÄßÊ∏¨Ë©¶</button>
                            <button class="btn btn-primary btn-sm" onclick="testAudioQuality()" disabled>üîä Èü≥Ë≥™Ê∏¨Ë©¶</button>
                            <button class="btn btn-primary btn-sm" onclick="testRealTimeEditing()" disabled>‚úèÔ∏è ÂØ¶ÊôÇÁ∑®ËºØ</button>
                        </div>
                    </div>

                    <!-- Êï¥ÂêàÊ∏¨Ë©¶ -->
                    <div class="test-group">
                        <button class="test-group-header" onclick="toggleTestGroup('integration')">
                            üîÑ Êï¥ÂêàÊ∏¨Ë©¶ <span id="integration-icon">‚ñº</span>
                        </button>
                        <div class="test-group-content" id="integration-tests">
                            <button class="btn btn-secondary btn-sm" onclick="testCrossFeatures()" disabled>üéØ Ë∑®ÂäüËÉΩÊ∏¨Ë©¶</button>
                            <button class="btn btn-secondary btn-sm" onclick="testDataPersistence()" disabled>üíæ Êï∏ÊìöÊåÅ‰πÖÂåñ</button>
                            <button class="btn btn-secondary btn-sm" onclick="testFullWorkflow()" disabled>üîÑ ÂÆåÊï¥Â∑•‰ΩúÊµÅ</button>
                        </div>
                    </div>
                </div>
                
                <div class="test-controls" style="margin-top: 15px;">
                    <button class="btn btn-success" onclick="runAllTests()" disabled id="runAllTestsBtn">
                        üöÄ ÈÅãË°åÂÖ®ÈÉ®Ê∏¨Ë©¶
                    </button>
                    <button class="btn btn-warning" onclick="runSelectedTests()" disabled id="runSelectedBtn">
                        ‚úÖ ÈÅãË°åÈÅ∏‰∏≠Ê∏¨Ë©¶
                    </button>
                    <button class="btn btn-danger" onclick="stopAllTests()" disabled id="stopTestsBtn">
                        ‚èπÔ∏è ÂÅúÊ≠¢Ê∏¨Ë©¶
                    </button>
                </div>
                
                <div class="test-results" style="margin-top: 10px;">
                    <div style="font-size: 12px; color: #a0aec0; margin-bottom: 5px;">Ê∏¨Ë©¶ÁµêÊûúÊ¶ÇË¶Ω:</div>
                    <div id="testResultsSummary" style="font-size: 11px; color: #718096;">Á≠âÂæÖÊ∏¨Ë©¶ÈÅãË°å...</div>
                </div>
            </div>
        </div>

        <!-- Track Grid -->
        <div class="track-grid" id="trackGrid">
            <!-- Track cards will be dynamically generated -->
        </div>

        <!-- Console -->
        <div class="console">
            <div class="console-header">
                <div class="console-title">üìä Á≥ªÁµ±Êó•Ë™å</div>
                <div class="console-controls">
                    <div class="log-filters">
                        <button class="btn btn-sm" onclick="filterLogs('all')" id="filterAll">ÂÖ®ÈÉ®</button>
                        <button class="btn btn-sm btn-danger" onclick="filterLogs('error')" id="filterError">‚ùå ÈåØË™§ (<span id="errorCount">0</span>)</button>
                        <button class="btn btn-sm btn-warning" onclick="filterLogs('warning')" id="filterWarning">‚ö†Ô∏è Ë≠¶Âëä (<span id="warningCount">0</span>)</button>
                        <button class="btn btn-sm btn-info" onclick="filterLogs('info')" id="filterInfo">‚ÑπÔ∏è ‰ø°ÊÅØ</button>
                        <button class="btn btn-sm btn-success" onclick="filterLogs('success')" id="filterSuccess">‚úÖ ÊàêÂäü</button>
                    </div>
                    <button class="btn btn-secondary" onclick="clearConsole()">Ê∏ÖÈô§Êó•Ë™å</button>
                    <button class="btn btn-danger" onclick="showErrorSummary()">üö® ÈåØË™§ÊëòË¶Å</button>
                </div>
            </div>
            <div class="console-content" id="consoleContent">
                <div class="log-entry">
                    <span class="log-time">[00:00:00]</span>
                    <span class="log-info">üéµ MIDI Clip Êí≠ÊîæÈ©óË≠âÁ≥ªÁµ±Ê≠£Âú®ÂàùÂßãÂåñ...</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // ÈÅéÊøæÁÄèË¶ΩÂô®Êì¥Â±ïÈåØË™§
        window.addEventListener('error', (event) => {
            if (event.filename && (
                event.filename.includes('inpage.js') || 
                event.filename.includes('content-script') ||
                event.filename.includes('extension') ||
                event.filename.includes('metamask')
            )) {
                event.preventDefault();
                return false;
            }
        });
        
        // Global State
        let musicService = null;
        let isSystemReady = false;
        let isAudioReady = false;
        let tracks = {};
        let progressInterval = null;
        
        // ÊôÇÈñìÁØÑÂúçÈ©óË≠âËºîÂä©ÂáΩÊï∏
        function validateNoteTimeRange(noteStart, noteEnd, clipStart, clipEnd, testName) {
            const absoluteNoteStart = noteStart;
            const absoluteNoteEnd = noteEnd;
            const clipDuration = clipEnd - clipStart;
            
            if (absoluteNoteStart < 0 || absoluteNoteEnd > clipDuration) {
                const errorMsg = `${testName}: Èü≥Á¨¶ÊôÇÈñìË∂ÖÂá∫ÁØÑÂúç - Èü≥Á¨¶[${absoluteNoteStart}-${absoluteNoteEnd}ms] Ë∂ÖÂá∫clip[0-${clipDuration}ms]`;
                log(`‚ö†Ô∏è ÊôÇÈñìÁØÑÂúçË≠¶Âëä: ${errorMsg}`, 'warning');
                return false;
            }
            return true;
        }
        
        // Track configurations for Twinkle Twinkle Little Star - Harmony Version
        const twinkleConfig = {
            high: {
                name: "üî¥ ‰∏ªÊóãÂæãËªåÈÅì (È´òÈü≥)",
                range: "C4-A4 (MIDI 60-69)",
                baseNote: 60, // C4
                notes: [
                    { note: 0, duration: 500 },  // C4 - Twinkle (CÂ§ßË™ø)
                    { note: 0, duration: 500 },  // C4 - twinkle 
                    { note: 7, duration: 500 },  // G4 - little (GÂ§ßË™ø)
                    { note: 7, duration: 500 },  // G4 - star 
                    { note: 9, duration: 500 },  // A4 - How I (AÂ∞èË™ø)
                    { note: 9, duration: 500 },  // A4 - wonder 
                    { note: 7, duration: 1000 }, // G4 - what you are (GÂ§ßË™ø Èï∑Èü≥)
                    { note: 5, duration: 500 },  // F4 - Up a- (FÂ§ßË™ø)
                    { note: 5, duration: 500 },  // F4 - bove the 
                    { note: 4, duration: 500 },  // E4 - world so (CÂ§ßË™ø/Am)
                    { note: 4, duration: 500 },  // E4 - high 
                    { note: 2, duration: 500 },  // D4 - Like a (GÂ§ßË™ø)
                    { note: 2, duration: 500 },  // D4 - diamond 
                    { note: 0, duration: 1000 }, // C4 - in the sky (CÂ§ßË™ø Èï∑Èü≥)
                ]
            },
            mid: {
                name: "üü¢ ÂíåËÅ≤ËªåÈÅì (‰∏≠Èü≥)",
                range: "C3-G4 (MIDI 48-67)",
                baseNote: 48, // C3
                notes: [
                    // do-so-mi-so pattern simplified - ÊØèÂ∞èÁØÄ‰∏ÄÂÄãÂæ™Áí∞
                    // Â∞èÁØÄ1-2: CÂ§ßË™ø (C-G-E-G)
                    { note: 0, duration: 250 },  // C3 - do
                    { note: 7, duration: 250 },  // G3 - so  
                    { note: 4, duration: 250 },  // E3 - mi
                    { note: 7, duration: 250 },  // G3 - so
                    { note: 0, duration: 250 },  // C3 - do
                    { note: 7, duration: 250 },  // G3 - so
                    { note: 4, duration: 250 },  // E3 - mi
                    { note: 7, duration: 250 },  // G3 - so
                    
                    // Â∞èÁØÄ3-4: GÂ§ßË™ø (G-D-B-D)
                    { note: 7, duration: 250 },  // G3 - do (GÂ§ßË™ø)
                    { note: 14, duration: 250 }, // D4 - so (GÂ§ßË™ø)
                    { note: 11, duration: 250 }, // B3 - mi (GÂ§ßË™ø)  
                    { note: 14, duration: 250 }, // D4 - so (GÂ§ßË™ø)
                    { note: 7, duration: 250 },  // G3 - do
                    { note: 14, duration: 250 }, // D4 - so
                    { note: 11, duration: 250 }, // B3 - mi
                    { note: 14, duration: 250 }, // D4 - so
                    
                    // Â∞èÁØÄ5-6: AÂ∞èË™ø (A-E-C-E)
                    { note: 9, duration: 250 },  // A3 - do (Am)
                    { note: 16, duration: 250 }, // E4 - so (Am)
                    { note: 12, duration: 250 }, // C4 - mi (Am)
                    { note: 16, duration: 250 }, // E4 - so (Am)
                    { note: 9, duration: 250 },  // A3 - do
                    { note: 16, duration: 250 }, // E4 - so
                    { note: 12, duration: 250 }, // C4 - mi  
                    { note: 16, duration: 250 }, // E4 - so
                    
                    // Â∞èÁØÄ7: GÂ§ßË™ø (G-D-B-D)
                    { note: 7, duration: 250 },  // G3 - do
                    { note: 14, duration: 250 }, // D4 - so
                    { note: 11, duration: 250 }, // B3 - mi
                    { note: 14, duration: 250 }, // D4 - so
                ]
            },
            low: {
                name: "üîµ ‰ΩéÈü≥ËªåÈÅì (Ê†πÈü≥)",
                range: "C2-A2 (MIDI 36-45)",
                baseNote: 36, // C2
                notes: [
                    { note: 0, duration: 1000 }, // C2 - CÂ§ßË™øÊ†πÈü≥
                    { note: 7, duration: 1000 }, // G2 - GÂ§ßË™øÊ†πÈü≥
                    { note: 9, duration: 1000 }, // A2 - AÂ∞èË™øÊ†πÈü≥
                    { note: 7, duration: 1000 }, // G2 - GÂ§ßË™øÊ†πÈü≥
                    { note: 5, duration: 1000 }, // F2 - FÂ§ßË™øÊ†πÈü≥
                    { note: 0, duration: 1000 }, // C2 - CÂ§ßË™øÊ†πÈü≥
                    { note: 7, duration: 1000 }, // G2 - GÂ§ßË™øÊ†πÈü≥
                    { note: 0, duration: 1000 }, // C2 - CÂ§ßË™øÁµêÊùüÊ†πÈü≥
                ]
            }
        };
        
        // Â∞èÊòüÊòüÈü≥Á¨¶ÂêçÁ®±Êò†Â∞Ñ
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Initialize the system
        window.initializeSystem = async function() {
            try {
                updateSystemStatus('loading', 'ËºâÂÖ• Music BC...');
                log('üöÄ ÈñãÂßãÂàùÂßãÂåñ MIDI Clip Êí≠ÊîæÈ©óË≠âÁ≥ªÁµ±...', 'info');
                
                // Load Music Arrangement BC
                const { MusicArrangementContainer, MusicArrangementTypes } = await import('/src/modules/music-arrangement/index.ts');
                
                log('üì¶ ÂâµÂª∫ Music BC ÂÆπÂô®...', 'info');
                const container = new MusicArrangementContainer();
                await container.initialize();
                
                musicService = container.get(MusicArrangementTypes.SimpleMusicArrangementService);
                
                // Initialize audio system
                log('üîä ÂàùÂßãÂåñÈü≥È†ªÁ≥ªÁµ±...', 'info');
                await musicService.initializeAudio();
                
                // System ready
                isSystemReady = true;
                isAudioReady = true;
                
                updateSystemStatus('ready', 'Music BC Â∞±Á∑í');
                updateAudioStatus('ready', 'Èü≥È†ªÂ∞±Á∑í');
                
                // Enable controls
                document.getElementById('initBtn').disabled = true;
                document.getElementById('createBtn').disabled = false;
                
                log('‚úÖ Á≥ªÁµ±ÂàùÂßãÂåñÂÆåÊàêÔºÅ', 'success');
                log('üéµ Ready to create Twinkle Twinkle Little Star tracks!', 'success');
                
            } catch (error) {
                log(`‚ùå Á≥ªÁµ±ÂàùÂßãÂåñÂ§±Êïó: ${error.message}`, 'error');
                updateSystemStatus('error', 'ÂàùÂßãÂåñÂ§±Êïó');
                updateAudioStatus('error', 'Èü≥È†ªÈåØË™§');
            }
        };
        
        // Create Twinkle Twinkle Little Star tracks
        window.createTwinkleTracks = async function() {
            try {
                if (!isSystemReady) {
                    log('‚ùå Á≥ªÁµ±Â∞öÊú™Â∞±Á∑í', 'error');
                    return;
                }
                
                log('üåü ÈñãÂßãÂâµÂª∫Â∞èÊòüÊòü‰∏âËÅ≤ÈÉ®ÂíåËÅ≤ËªåÈÅì...', 'info');
                updatePlaybackStatus('ÂâµÂª∫‰∏≠');
                
                // Create tracks for each range
                for (const [key, config] of Object.entries(twinkleConfig)) {
                    try {
                        log(`üéõÔ∏è ÂâµÂª∫ ${config.name}...`, 'info');
                        
                        // Create track
                        const trackId = await musicService.createTrack('test-user', 'INSTRUMENT', config.name);
                        log(`‚úÖ ËªåÈÅìÂ∑≤ÂâµÂª∫: ${trackId}`, 'success');
                        
                        // Create MIDI clip
                        const clipId = await musicService.createMidiClip(
                            trackId,
                            { startTime: 0, endTime: 8000 }, // 8 seconds for the full melody
                            { type: 'synth', name: `Twinkle Synth ${key.toUpperCase()}` },
                            `Â∞èÊòüÊòü ${key.toUpperCase()} Clip`
                        );
                        log(`üéπ MIDI Clip Â∑≤ÂâµÂª∫: ${clipId}`, 'success');
                        
                        // Add notes to clip
                        let currentTime = 0;
                        const noteIds = [];
                        
                        for (let i = 0; i < config.notes.length; i++) {
                            const noteConfig = config.notes[i];
                            const midiNote = config.baseNote + noteConfig.note;
                            const velocity = 100;
                            
                            const noteId = await musicService.addMidiNote(
                                trackId,
                                clipId,
                                midiNote,
                                velocity,
                                { startTime: currentTime, endTime: currentTime + noteConfig.duration }
                            );
                            
                            noteIds.push(noteId);
                            currentTime += noteConfig.duration;
                            
                            log(`üéµ Èü≥Á¨¶Â∑≤Ê∑ªÂä†: ${noteNames[noteConfig.note]} (MIDI ${midiNote}) Âú® ${currentTime}ms`, 'debug');
                        }
                        
                        // Store track info
                        tracks[key] = {
                            trackId,
                            clipId,
                            noteIds,
                            config,
                            noteCount: config.notes.length
                        };
                        
                        // Add track to adapter
                        await musicService.addTrackToAdapter(trackId);
                        log(`üîó ËªåÈÅìÂ∑≤Ê∑ªÂä†Âà∞ÈÅ©ÈÖçÂô®: ${trackId}`, 'success');
                        
                    } catch (trackError) {
                        log(`‚ùå ÂâµÂª∫ ${config.name} Â§±Êïó: ${trackError.message}`, 'error');
                    }
                }
                
                // Update UI
                updateTrackGrid();
                updateStats();
                updatePlaybackStatus('Â∞±Á∑í');
                
                // Enable play controls
                document.getElementById('playAllBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('sequentialBtn').disabled = false;
                document.getElementById('testHighBtn').disabled = false;
                document.getElementById('testMidBtn').disabled = false;
                document.getElementById('testLowBtn').disabled = false;
                document.getElementById('clearBtn').disabled = false;
                
                // Enable performance test controls
                document.getElementById('perfTestBasicBtn').disabled = false;
                document.getElementById('perfTestHeavyBtn').disabled = false;
                document.getElementById('perfTestMemoryBtn').disabled = false;
                document.getElementById('perfTestConcurrencyBtn').disabled = false;
                
                // Enable all comprehensive test controls
                enableAllTestButtons();
                document.getElementById('runAllTestsBtn').disabled = false;
                document.getElementById('runSelectedBtn').disabled = false;
                document.getElementById('stopTestsBtn').disabled = false;
                
                log('üéâ ÊâÄÊúâÂ∞èÊòüÊòüËªåÈÅìÂâµÂª∫ÂÆåÊàêÔºÅ', 'success');
                log(`üìä ÂâµÂª∫Áµ±Ë®à: ${Object.keys(tracks).length} ÂÄãËªåÈÅì, Á∏ΩË®à ${getTotalNoteCount()} ÂÄãÈü≥Á¨¶`, 'info');
                
            } catch (error) {
                log(`‚ùå ÂâµÂª∫ËªåÈÅìÂ§±Êïó: ${error.message}`, 'error');
                updatePlaybackStatus('ÈåØË™§');
            }
        };
        
        // Play all tracks simultaneously
        window.playAllTracks = async function() {
            try {
                if (!isSystemReady || Object.keys(tracks).length === 0) {
                    log('‚ùå Á≥ªÁµ±Êú™Â∞±Á∑íÊàñÁÑ°ËªåÈÅìÂèØÊí≠Êîæ', 'error');
                    return;
                }
                
                log('üéµ ÈñãÂßãÊí≠ÊîæÊâÄÊúâËªåÈÅìÔºà‰∏âÈü≥ÂüüÂêåÊôÇÊí≠ÊîæÔºâ...', 'info');
                updatePlaybackStatus('Êí≠Êîæ‰∏≠');
                
                // Start progress bar
                startProgress(8000); // 8 seconds total duration
                
                // Play all tracks using Music BC
                await musicService.playAllTracks();
                
                log('‚úÖ ‰∏âÈü≥ÂüüÂ∞èÊòüÊòüÊí≠ÊîæÈñãÂßãÔºÅ', 'success');
                log('üîä ‰Ω†ÊáâË©≤ËÅΩÂà∞È´ò‰∏≠‰ΩéÈü≥ÂêåÊôÇÊºîÂ•èÁöÑÂ∞èÊòüÊòüÊóãÂæã', 'info');
                
                // Auto stop after duration
                setTimeout(() => {
                    updatePlaybackStatus('ÂÆåÊàê');
                    stopProgress();
                }, 8000);
                
            } catch (error) {
                log(`‚ùå Êí≠ÊîæÂ§±Êïó: ${error.message}`, 'error');
                updatePlaybackStatus('ÈåØË™§');
                stopProgress();
            }
        };
        
        // Stop all tracks
        window.stopAllTracks = async function() {
            try {
                log('‚èπÔ∏è ÂÅúÊ≠¢ÊâÄÊúâËªåÈÅìÊí≠Êîæ...', 'info');
                
                if (musicService) {
                    await musicService.stopAllTracks();
                }
                
                updatePlaybackStatus('Â∑≤ÂÅúÊ≠¢');
                stopProgress();
                
                log('‚úÖ Êí≠ÊîæÂ∑≤ÂÅúÊ≠¢', 'success');
                
            } catch (error) {
                log(`‚ùå ÂÅúÊ≠¢Êí≠ÊîæÂ§±Êïó: ${error.message}`, 'error');
            }
        };
        
        // Play tracks sequentially
        window.playSequential = async function() {
            try {
                if (!isSystemReady || Object.keys(tracks).length === 0) {
                    log('‚ùå Á≥ªÁµ±Êú™Â∞±Á∑íÊàñÁÑ°ËªåÈÅìÂèØÊí≠Êîæ', 'error');
                    return;
                }
                
                log('üéµ ÈñãÂßã‰æùÂ∫èÊí≠ÊîæËªåÈÅìÔºàÈ´ò‚Üí‰∏≠‚Üí‰ΩéÔºâ...', 'info');
                updatePlaybackStatus('‰æùÂ∫èÊí≠Êîæ');
                
                // Start progress bar for full sequence
                startProgress(24000); // 3 x 8 seconds
                
                const sequence = ['high', 'mid', 'low'];
                
                for (let i = 0; i < sequence.length; i++) {
                    const key = sequence[i];
                    const track = tracks[key];
                    
                    if (track) {
                        log(`üéµ Êí≠Êîæ ${track.config.name}...`, 'info');
                        markTrackActive(key);
                        
                        // Play single track
                        await musicService.playMidiClip(track.trackId, track.clipId);
                        
                        // Wait for completion
                        await new Promise(resolve => setTimeout(resolve, 8000));
                        
                        clearTrackActive();
                        log(`‚úÖ ${track.config.name} Êí≠ÊîæÂÆåÊàê`, 'success');
                    }
                }
                
                updatePlaybackStatus('Â∫èÂàóÂÆåÊàê');
                stopProgress();
                
                log('üéâ ‰æùÂ∫èÊí≠ÊîæÂÆåÊàêÔºÅ', 'success');
                
            } catch (error) {
                log(`‚ùå ‰æùÂ∫èÊí≠ÊîæÂ§±Êïó: ${error.message}`, 'error');
                updatePlaybackStatus('ÈåØË™§');
                stopProgress();
            }
        };
        
        // Test single track
        window.testSingleTrack = async function(trackKey) {
            try {
                const track = tracks[trackKey];
                if (!track) {
                    log(`‚ùå ËªåÈÅì ${trackKey} ‰∏çÂ≠òÂú®`, 'error');
                    return;
                }
                
                log(`üîß Ê∏¨Ë©¶ ${track.config.name}...`, 'info');
                updatePlaybackStatus(`Ê∏¨Ë©¶${trackKey.toUpperCase()}`);
                
                markTrackActive(trackKey);
                startProgress(8000);
                
                // Play the specific MIDI clip
                await musicService.playMidiClip(track.trackId, track.clipId);
                
                log(`‚úÖ ${track.config.name} Ê∏¨Ë©¶ÈñãÂßã`, 'success');
                log(`üîä Êí≠Êîæ ${track.noteCount} ÂÄãÈü≥Á¨¶Âú® ${track.config.range} ÁØÑÂúç`, 'info');
                
                // Auto complete after duration
                setTimeout(() => {
                    updatePlaybackStatus('Ê∏¨Ë©¶ÂÆåÊàê');
                    clearTrackActive();
                    stopProgress();
                }, 8000);
                
            } catch (error) {
                log(`‚ùå Ê∏¨Ë©¶ ${trackKey} ËªåÈÅìÂ§±Êïó: ${error.message}`, 'error');
                updatePlaybackStatus('Ê∏¨Ë©¶ÈåØË™§');
                clearTrackActive();
                stopProgress();
            }
        };
        
        // Clear all tracks
        window.clearAllTracks = async function() {
            try {
                if (Object.keys(tracks).length === 0) {
                    log('‚ö†Ô∏è Ê≤íÊúâËªåÈÅìÈúÄË¶ÅÊ∏ÖÈô§', 'warning');
                    return;
                }
                
                if (!confirm('Á¢∫ÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâËªåÈÅìÂóéÔºü')) {
                    return;
                }
                
                log('üóëÔ∏è Ê∏ÖÈô§ÊâÄÊúâËªåÈÅì...', 'info');
                
                // Stop any playing tracks
                await stopAllTracks();
                
                // Clear tracks data
                tracks = {};
                
                // Update UI
                updateTrackGrid();
                updateStats();
                updatePlaybackStatus('Â∑≤Ê∏ÖÈô§');
                
                // Disable controls
                document.getElementById('playAllBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('sequentialBtn').disabled = true;
                document.getElementById('testHighBtn').disabled = true;
                document.getElementById('testMidBtn').disabled = true;
                document.getElementById('testLowBtn').disabled = true;
                document.getElementById('clearBtn').disabled = true;
                
                // Disable performance test controls
                document.getElementById('perfTestBasicBtn').disabled = true;
                document.getElementById('perfTestHeavyBtn').disabled = true;
                document.getElementById('perfTestMemoryBtn').disabled = true;
                document.getElementById('perfTestConcurrencyBtn').disabled = true;
                
                // Disable all comprehensive test controls
                disableAllTestButtons();
                document.getElementById('runAllTestsBtn').disabled = true;
                document.getElementById('runSelectedBtn').disabled = true;
                document.getElementById('stopTestsBtn').disabled = true;
                
                log('‚úÖ ÊâÄÊúâËªåÈÅìÂ∑≤Ê∏ÖÈô§', 'success');
                
            } catch (error) {
                log(`‚ùå Ê∏ÖÈô§ËªåÈÅìÂ§±Êïó: ${error.message}`, 'error');
            }
        };
        
        // Update track grid UI
        function updateTrackGrid() {
            const grid = document.getElementById('trackGrid');
            grid.innerHTML = '';
            
            if (Object.keys(tracks).length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #718096;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üéµ</div>
                        <div style="font-size: 18px; margin-bottom: 8px;">Â∞öÊú™ÂâµÂª∫ËªåÈÅì</div>
                        <div style="font-size: 14px;">ÈªûÊìä„ÄåÂâµÂª∫Â∞èÊòüÊòüËªåÈÅì„ÄçÈñãÂßã</div>
                    </div>
                `;
                return;
            }
            
            for (const [key, track] of Object.entries(tracks)) {
                const config = track.config;
                const card = document.createElement('div');
                card.className = 'track-card';
                card.id = `track-${key}`;
                
                // Generate notes display
                const notesHtml = config.notes.slice(0, 20).map((note, index) => {
                    const noteName = noteNames[note.note];
                    const midiNum = config.baseNote + note.note;
                    return `<div class="note-item ${key}" title="MIDI ${midiNum}">${noteName}</div>`;
                }).join('');
                
                const moreNotesText = config.notes.length > 20 ? 
                    `<div class="note-item" style="background: #718096;">+${config.notes.length - 20} Êõ¥Â§ö...</div>` : '';
                
                card.innerHTML = `
                    <div class="track-header">
                        <div class="track-title">${config.name}</div>
                        <div class="track-range">${config.range}</div>
                    </div>
                    <div class="track-info">
                        <div>üìã ËªåÈÅìID: ${track.trackId.substring(0, 12)}...</div>
                        <div>üéπ ÁâáÊÆµID: ${track.clipId.substring(0, 12)}...</div>
                        <div>üéµ Èü≥Á¨¶Êï∏Èáè: ${track.noteCount} ÂÄã</div>
                        <div>‚è±Ô∏è Á∏ΩÊôÇÈï∑: 8.0 Áßí</div>
                    </div>
                    <div class="note-sequence">
                        <h5>üéº ${key === 'mid' ? 'do-so-mi-so 8ÂàÜÈü≥Á¨¶Ê®°Âºè' : 'Â∞èÊòüÊòüÊóãÂæãÈü≥Á¨¶'}:</h5>
                        <div class="notes-display">${notesHtml}${moreNotesText}</div>
                    </div>
                    <div class="track-controls">
                        <button class="btn btn-primary" onclick="testSingleTrack('${key}')">
                            ‚ñ∂Ô∏è Êí≠ÊîæÊ≠§ËªåÈÅì
                        </button>
                        <button class="btn btn-info" onclick="inspectTrack('${key}')">
                            üîç Ê™¢Êü•ÁãÄÊÖã
                        </button>
                    </div>
                `;
                
                grid.appendChild(card);
            }
        }
        
        // Mark track as active
        function markTrackActive(trackKey) {
            clearTrackActive();
            const card = document.getElementById(`track-${trackKey}`);
            if (card) {
                card.classList.add('active');
            }
        }
        
        // Clear all track active states
        function clearTrackActive() {
            document.querySelectorAll('.track-card').forEach(card => {
                card.classList.remove('active');
            });
        }
        
        // Inspect track state
        window.inspectTrack = async function(trackKey) {
            try {
                const track = tracks[trackKey];
                if (!track) {
                    log(`‚ùå ËªåÈÅì ${trackKey} ‰∏çÂ≠òÂú®`, 'error');
                    return;
                }
                
                log(`üîç Ê™¢Êü• ${track.config.name} ÁãÄÊÖã...`, 'info');
                
                // Debug adapter state
                await musicService.debugAdapterState();
                
                // Debug audio chain
                await musicService.debugAudioChain(track.trackId);
                
                log(`üìä ËªåÈÅìË©≥ÊÉÖ:`, 'info');
                log(`  ËªåÈÅìID: ${track.trackId}`, 'debug');
                log(`  ÁâáÊÆµID: ${track.clipId}`, 'debug');
                log(`  Èü≥Á¨¶Êï∏Èáè: ${track.noteCount}`, 'debug');
                log(`  Èü≥ÂüüÁØÑÂúç: ${track.config.range}`, 'debug');
                log(`  Âü∫Ê∫ñÈü≥Á¨¶: ${track.config.baseNote}`, 'debug');
                
                log(`‚úÖ ${track.config.name} ÁãÄÊÖãÊ™¢Êü•ÂÆåÊàê`, 'success');
                
            } catch (error) {
                log(`‚ùå Ê™¢Êü•ËªåÈÅì ${trackKey} Â§±Êïó: ${error.message}`, 'error');
            }
        };
        
        // Update statistics
        function updateStats() {
            document.getElementById('trackCount').textContent = Object.keys(tracks).length;
            document.getElementById('clipCount').textContent = Object.keys(tracks).length;
            document.getElementById('noteCount').textContent = getTotalNoteCount();
        }
        
        // Get total note count
        function getTotalNoteCount() {
            return Object.values(tracks).reduce((total, track) => total + track.noteCount, 0);
        }
        
        // Update system status
        function updateSystemStatus(type, text) {
            const status = document.getElementById('systemStatus');
            const iconMap = {
                'loading': '<span class="loading-spinner"></span>',
                'ready': '‚úÖ',
                'error': '‚ùå'
            };
            
            status.innerHTML = `${iconMap[type]} ${text}`;
            status.className = `status-indicator status-${type}`;
        }
        
        // Update audio status
        function updateAudioStatus(type, text) {
            const status = document.getElementById('audioStatus');
            const iconMap = {
                'loading': 'üîÑ',
                'ready': 'üîä',
                'error': 'üîá'
            };
            
            status.innerHTML = `${iconMap[type]} ${text}`;
            status.className = `status-indicator status-${type}`;
        }
        
        // Update playback status
        function updatePlaybackStatus(status) {
            document.getElementById('playbackStatus').textContent = status;
        }
        
        // Progress bar management
        function startProgress(duration) {
            const fill = document.getElementById('progressFill');
            const startTime = Date.now();
            
            progressInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                fill.style.width = progress + '%';
                
                if (progress >= 100) {
                    stopProgress();
                }
            }, 50);
        }
        
        function stopProgress() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            document.getElementById('progressFill').style.width = '0%';
        }
        
        // Console management
        let logEntries = [];
        let currentLogFilter = 'all';
        
        function log(message, type = 'info') {
            const output = document.getElementById('consoleContent');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.setAttribute('data-type', type);
            entry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-${type}">${message}</span>
            `;
            
            // Store entry data
            const logData = {
                time,
                message,
                type,
                element: entry
            };
            logEntries.push(logData);
            
            output.appendChild(entry);
            output.scrollTop = output.scrollHeight;
            
            // Update counters
            updateLogCounters();
            
            // Apply current filter
            if (currentLogFilter !== 'all' && type !== currentLogFilter) {
                entry.classList.add('hidden');
            }
        }
        
        function updateLogCounters() {
            const errorCount = logEntries.filter(entry => entry.type === 'error').length;
            const warningCount = logEntries.filter(entry => entry.type === 'warning').length;
            
            document.getElementById('errorCount').textContent = errorCount;
            document.getElementById('warningCount').textContent = warningCount;
            
            // Update filter button styles
            const errorBtn = document.getElementById('filterError');
            const warningBtn = document.getElementById('filterWarning');
            
            if (errorCount > 0) {
                errorBtn.style.background = '#e53e3e';
                errorBtn.style.animation = 'pulse 2s infinite';
            }
            
            if (warningCount > 0) {
                warningBtn.style.background = '#d69e2e';
            }
        }
        
        // Filter logs by type
        window.filterLogs = function(type) {
            currentLogFilter = type;
            
            // Reset all filter button styles
            document.querySelectorAll('.log-filters .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activate current filter button
            document.getElementById(`filter${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.add('active');
            
            // Show/hide log entries
            logEntries.forEach(entry => {
                if (type === 'all' || entry.type === type) {
                    entry.element.classList.remove('hidden');
                } else {
                    entry.element.classList.add('hidden');
                }
            });
            
            log(`üìã Êó•Ë™åÈÅéÊøæ: ${type === 'all' ? 'È°ØÁ§∫ÂÖ®ÈÉ®' : type}`, 'info');
        };
        
        // Show error summary
        window.showErrorSummary = function() {
            const errors = logEntries.filter(entry => entry.type === 'error');
            const warnings = logEntries.filter(entry => entry.type === 'warning');
            
            if (errors.length === 0 && warnings.length === 0) {
                log('‚úÖ Ê≤íÊúâÁôºÁèæÈåØË™§ÊàñË≠¶ÂëäÔºÅ', 'success');
                return;
            }
            
            // Create backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'error-summary-backdrop';
            backdrop.onclick = closeErrorSummary;
            
            // Create summary modal
            const modal = document.createElement('div');
            modal.className = 'error-summary';
            modal.id = 'errorSummaryModal';
            
            let summaryContent = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="color: #e53e3e; margin: 0;">üö® ÈåØË™§ËàáË≠¶ÂëäÊëòË¶Å</h3>
                    <button class="btn btn-secondary" onclick="closeErrorSummary()">‚úï</button>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="background: #2d3748; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="color: #e53e3e; font-size: 18px; margin-bottom: 10px;">‚ùå ÈåØË™§ (${errors.length} È†Ö)</div>
                        <div style="color: #d69e2e; font-size: 16px;">‚ö†Ô∏è Ë≠¶Âëä (${warnings.length} È†Ö)</div>
                    </div>
                </div>
            `;
            
            if (errors.length > 0) {
                summaryContent += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #e53e3e; margin-bottom: 10px;">üî• ÈåØË™§Ë©≥ÊÉÖ:</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #0a0a0a; border-radius: 6px; padding: 10px;">
                `;
                
                errors.forEach((error, index) => {
                    summaryContent += `
                        <div style="margin-bottom: 8px; padding: 8px; background: #1a1a1a; border-left: 3px solid #e53e3e; border-radius: 4px;">
                            <div style="color: #718096; font-size: 11px; margin-bottom: 4px;">[${error.time}] ÈåØË™§ #${index + 1}</div>
                            <div style="color: #fc8181; font-size: 13px;">${error.message}</div>
                        </div>
                    `;
                });
                
                summaryContent += `</div></div>`;
            }
            
            if (warnings.length > 0) {
                summaryContent += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #d69e2e; margin-bottom: 10px;">‚ö†Ô∏è Ë≠¶ÂëäË©≥ÊÉÖ:</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #0a0a0a; border-radius: 6px; padding: 10px;">
                `;
                
                warnings.forEach((warning, index) => {
                    summaryContent += `
                        <div style="margin-bottom: 8px; padding: 8px; background: #1a1a1a; border-left: 3px solid #d69e2e; border-radius: 4px;">
                            <div style="color: #718096; font-size: 11px; margin-bottom: 4px;">[${warning.time}] Ë≠¶Âëä #${index + 1}</div>
                            <div style="color: #f6e05e; font-size: 13px;">${warning.message}</div>
                        </div>
                    `;
                });
                
                summaryContent += `</div></div>`;
            }
            
            // Add suggestions
            summaryContent += `
                <div style="background: #2d3748; padding: 15px; border-radius: 8px; border-left: 4px solid #3182ce;">
                    <h4 style="color: #63b3ed; margin-bottom: 10px;">üí° Âª∫Ë≠∞:</h4>
                    <ul style="color: #e2e8f0; padding-left: 20px; margin: 0;">
                        <li>Ê™¢Êü•Á∂≤Áµ°ÈÄ£Êé•ÂíåÈü≥È†ªË®≠ÂÇôË®≠ÁΩÆ</li>
                        <li>Á¢∫‰øùÁÄèË¶ΩÂô®Â∑≤ÂïüÁî®Èü≥È†ªÊí≠ÊîæÊ¨äÈôê</li>
                        <li>ÂòóË©¶ÈáçÊñ∞ÂàùÂßãÂåñÁ≥ªÁµ±</li>
                        <li>Êü•ÁúãÁÄèË¶ΩÂô®ÊéßÂà∂Âè∞ÊòØÂê¶ÊúâÈ°çÂ§ñÈåØË™§‰ø°ÊÅØ</li>
                    </ul>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-success" onclick="copyErrorReport()">üìã Ë§áË£ΩÈåØË™§Â†±Âëä</button>
                    <button class="btn btn-warning" onclick="filterLogs('error'); closeErrorSummary();">üîç Êü•ÁúãÈåØË™§Êó•Ë™å</button>
                </div>
            `;
            
            modal.innerHTML = summaryContent;
            
            // Add to page
            document.body.appendChild(backdrop);
            document.body.appendChild(modal);
        };
        
        // Close error summary
        window.closeErrorSummary = function() {
            const backdrop = document.querySelector('.error-summary-backdrop');
            const modal = document.getElementById('errorSummaryModal');
            
            if (backdrop) backdrop.remove();
            if (modal) modal.remove();
        };
        
        // Copy error report
        window.copyErrorReport = function() {
            const errors = logEntries.filter(entry => entry.type === 'error');
            const warnings = logEntries.filter(entry => entry.type === 'warning');
            
            let report = `üö® MIDI Clip Êí≠ÊîæÈ©óË≠âÁ≥ªÁµ± - ÈåØË™§Â†±Âëä\n`;
            report += `üìÖ ÁîüÊàêÊôÇÈñì: ${new Date().toLocaleString()}\n`;
            report += `üìä Áµ±Ë®à: ${errors.length} ÂÄãÈåØË™§, ${warnings.length} ÂÄãË≠¶Âëä\n\n`;
            
            if (errors.length > 0) {
                report += `‚ùå ÈåØË™§ÂàóË°®:\n`;
                errors.forEach((error, index) => {
                    report += `${index + 1}. [${error.time}] ${error.message}\n`;
                });
                report += `\n`;
            }
            
            if (warnings.length > 0) {
                report += `‚ö†Ô∏è Ë≠¶ÂëäÂàóË°®:\n`;
                warnings.forEach((warning, index) => {
                    report += `${index + 1}. [${warning.time}] ${warning.message}\n`;
                });
                report += `\n`;
            }
            
            report += `üåê ÁÄèË¶ΩÂô®‰ø°ÊÅØ: ${navigator.userAgent}\n`;
            report += `üéµ Áî®Êà∂‰ª£ÁêÜ: ${navigator.platform}\n`;
            
            navigator.clipboard.writeText(report).then(() => {
                log('üìã ÈåØË™§Â†±ÂëäÂ∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÊùø', 'success');
            }).catch(() => {
                log('‚ùå Ë§áË£ΩÂ§±ÊïóÔºåË´ãÊâãÂãïÈÅ∏ÊìáÊñáÊú¨', 'error');
            });
        };
        
        window.clearConsole = function() {
            document.getElementById('consoleContent').innerHTML = '';
            logEntries = [];
            updateLogCounters();
            log('üßπ Êó•Ë™åÂ∑≤Ê∏ÖÈô§', 'info');
        };
        
        // Update current time
        function updateCurrentTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            document.getElementById('currentTime').textContent = timeStr;
        }
        
        // Start time update
        setInterval(updateCurrentTime, 1000);
        updateCurrentTime();
        
        // Initial UI update
        updateStats();
        updateTrackGrid();
        
        // Initialization message
        log('üéµ MIDI Clip Êí≠ÊîæÈ©óË≠âÁ≥ªÁµ±Â∑≤ËºâÂÖ•', 'info');
        log('üåü Ê∫ñÂÇôÊ∏¨Ë©¶Â∞èÊòüÊòü‰∏âÈü≥ÂüüÁâàÊú¨', 'info');
        log('üöÄ ÈªûÊìä„ÄåÂàùÂßãÂåñÁ≥ªÁµ±„ÄçÈñãÂßã', 'info');
        log('üîß v2.1 - ‰øÆÂæ©ÊôÇÈñìÁØÑÂúçÈåØË™§ÔºåÂÑ™ÂåñÊ∏¨Ë©¶Á©©ÂÆöÊÄß', 'info');
        
        // ============ ÊÄßËÉΩÊ∏¨Ë©¶ÂáΩÊï∏ ============
        
        // Âü∫Á§éÊÄßËÉΩÊ∏¨Ë©¶
        window.performanceTestBasic = async function() {
            try {
                log('üöÄ ÈñãÂßãÂü∫Á§éÊÄßËÉΩÊ∏¨Ë©¶...', 'info');
                updatePerfResults('Ê∏¨Ë©¶‰∏≠...');
                
                const startTime = performance.now();
                
                // Ê∏¨Ë©¶ËªåÈÅìÂâµÂª∫ÈÄüÂ∫¶
                log('üìä Ê∏¨Ë©¶ËªåÈÅìÂâµÂª∫ÊÄßËÉΩ...', 'info');
                const trackCreationStart = performance.now();
                
                const testTrackId = await musicService.createTrack('perf-test', 'INSTRUMENT', 'Performance Test Track');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 2000 },
                    { type: 'synth', name: 'Perf Test Synth' },
                    'Performance Test Clip'
                );
                
                // Ê∑ªÂä†10ÂÄãÈü≥Á¨¶
                for (let i = 0; i < 10; i++) {
                    await musicService.addMidiNote(
                        testTrackId,
                        clipId,
                        60 + (i % 12),
                        100,
                        { startTime: i * 100, endTime: (i * 100) + 100 }
                    );
                }
                
                const trackCreationEnd = performance.now();
                const creationTime = trackCreationEnd - trackCreationStart;
                
                // Ê∏¨Ë©¶Êí≠ÊîæÈüøÊáâÈÄüÂ∫¶
                log('üìä Ê∏¨Ë©¶Êí≠ÊîæÈüøÊáâÊÄßËÉΩ...', 'info');
                const playbackStart = performance.now();
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                const playbackEnd = performance.now();
                const playbackTime = playbackEnd - playbackStart;
                
                const totalTime = performance.now() - startTime;
                
                const results = `
                    ‚úÖ Âü∫Á§éÊÄßËÉΩÊ∏¨Ë©¶ÂÆåÊàê
                    üìä ËªåÈÅìÂâµÂª∫ÊôÇÈñì: ${creationTime.toFixed(2)}ms
                    üéµ Êí≠ÊîæÈüøÊáâÊôÇÈñì: ${playbackTime.toFixed(2)}ms
                    ‚è±Ô∏è Á∏ΩÊ∏¨Ë©¶ÊôÇÈñì: ${totalTime.toFixed(2)}ms
                    üéØ ÁãÄÊÖã: ${creationTime < 1000 && playbackTime < 500 ? 'ÂÑ™ÁßÄ' : creationTime < 2000 && playbackTime < 1000 ? 'ËâØÂ•Ω' : 'ÈúÄË¶ÅÂÑ™Âåñ'}
                `;
                
                updatePerfResults(results);
                log('üéâ Âü∫Á§éÊÄßËÉΩÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                
            } catch (error) {
                log(`‚ùå Âü∫Á§éÊÄßËÉΩÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updatePerfResults(`‚ùå Ê∏¨Ë©¶Â§±Êïó: ${error.message}`);
            }
        };
        
        // ÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶
        window.performanceTestHeavy = async function() {
            try {
                log('üî• ÈñãÂßãÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶...', 'info');
                updatePerfResults('ÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶‰∏≠...');
                
                const startTime = performance.now();
                
                // ÂâµÂª∫Â§öÂÄãËªåÈÅìÂíåÂ§ßÈáèÈü≥Á¨¶
                log('üìä ÂâµÂª∫5ÂÄãËªåÈÅìÔºåÊØèÂÄãËªåÈÅì100ÂÄãÈü≥Á¨¶...', 'info');
                const trackIds = [];
                
                for (let trackIndex = 0; trackIndex < 5; trackIndex++) {
                    const trackId = await musicService.createTrack('heavy-test', 'INSTRUMENT', `Heavy Test Track ${trackIndex + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 10000 },
                        { type: 'synth', name: `Heavy Synth ${trackIndex + 1}` },
                        `Heavy Clip ${trackIndex + 1}`
                    );
                    
                    // ÊØèÂÄãËªåÈÅìÊ∑ªÂä†100ÂÄãÈü≥Á¨¶
                    for (let noteIndex = 0; noteIndex < 100; noteIndex++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (noteIndex % 25),
                            100,
                            { startTime: noteIndex * 50, endTime: (noteIndex * 50) + 40 }
                        );
                    }
                    
                    trackIds.push(trackId);
                    await musicService.addTrackToAdapter(trackId);
                    
                    log(`‚úÖ ËªåÈÅì ${trackIndex + 1}/5 ÂâµÂª∫ÂÆåÊàê`, 'info');
                }
                
                // Ê∏¨Ë©¶‰∏¶ÁôºÊí≠Êîæ
                log('üìä Ê∏¨Ë©¶‰∏¶ÁôºÊí≠ÊîæÊâÄÊúâËªåÈÅì...', 'info');
                const playbackStart = performance.now();
                
                await musicService.playAllTracks();
                
                const playbackEnd = performance.now();
                const totalTime = performance.now() - startTime;
                
                const results = `
                    ‚úÖ ÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶ÂÆåÊàê
                    üìä ÂâµÂª∫5ËªåÈÅì500Èü≥Á¨¶: ${totalTime.toFixed(2)}ms
                    üéµ ‰∏¶ÁôºÊí≠ÊîæÈüøÊáâ: ${(playbackEnd - playbackStart).toFixed(2)}ms
                    üí™ Ë≤†ËºâËôïÁêÜËÉΩÂäõ: ${totalTime < 10000 ? 'ÂÑ™ÁßÄ' : totalTime < 20000 ? 'ËâØÂ•Ω' : 'ÈúÄË¶ÅÂÑ™Âåñ'}
                    üìà Âπ≥ÂùáÊØèÈü≥Á¨¶ËôïÁêÜ: ${(totalTime / 500).toFixed(2)}ms
                `;
                
                updatePerfResults(results);
                log('üéâ ÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                
                // Á≠âÂæÖÊí≠ÊîæÂÆåÊàêÂæåÊ∏ÖÁêÜ
                setTimeout(async () => {
                    await musicService.stopAllTracks();
                    log('üßπ ÈáçÂ∫¶Ê∏¨Ë©¶Ê∏ÖÁêÜÂÆåÊàê', 'info');
                }, 3000);
                
            } catch (error) {
                log(`‚ùå ÈáçÂ∫¶Ë≤†ËºâÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updatePerfResults(`‚ùå ÈáçÂ∫¶Ê∏¨Ë©¶Â§±Êïó: ${error.message}`);
            }
        };
        
        // Ë®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶
        window.performanceTestMemory = async function() {
            try {
                log('üíæ ÈñãÂßãË®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶...', 'info');
                updatePerfResults('Ë®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶‰∏≠...');
                
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const startTime = performance.now();
                
                // ÂâµÂª∫Â§ßÈáèËªåÈÅì‰ΩÜ‰∏çÊí≠Êîæ
                log('üìä ÂâµÂª∫20ÂÄãËªåÈÅìÁî®ÊñºË®òÊÜ∂È´îÊ∏¨Ë©¶...', 'info');
                const memoryTrackIds = [];
                
                for (let i = 0; i < 20; i++) {
                    const trackId = await musicService.createTrack('memory-test', 'INSTRUMENT', `Memory Test Track ${i + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 5000 },
                        { type: 'synth', name: `Memory Synth ${i + 1}` },
                        `Memory Clip ${i + 1}`
                    );
                    
                    // ÊØèÂÄãËªåÈÅìÊ∑ªÂä†50ÂÄãÈü≥Á¨¶
                    for (let j = 0; j < 50; j++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (j % 12),
                            100,
                            { startTime: j * 80, endTime: (j * 80) + 60 }
                        );
                    }
                    
                    memoryTrackIds.push(trackId);
                    
                    if (i % 5 === 4) {
                        log(`üìä Ë®òÊÜ∂È´îÊ∏¨Ë©¶ÈÄ≤Â∫¶: ${i + 1}/20`, 'info');
                    }
                }
                
                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryUsed = finalMemory - initialMemory;
                const totalTime = performance.now() - startTime;
                
                const results = `
                    ‚úÖ Ë®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶ÂÆåÊàê
                    üìä ÂâµÂª∫20ËªåÈÅì1000Èü≥Á¨¶: ${totalTime.toFixed(2)}ms
                    üíæ Ë®òÊÜ∂È´î‰ΩøÁî®Â¢ûÈáè: ${(memoryUsed / 1024 / 1024).toFixed(2)} MB
                    üìà Âπ≥ÂùáÊØèËªåÈÅìË®òÊÜ∂È´î: ${(memoryUsed / 20 / 1024).toFixed(2)} KB
                    üéØ Ë®òÊÜ∂È´îÊïàÁéá: ${memoryUsed < 50 * 1024 * 1024 ? 'ÂÑ™ÁßÄ' : memoryUsed < 100 * 1024 * 1024 ? 'ËâØÂ•Ω' : 'ÈúÄË¶ÅÂÑ™Âåñ'}
                `;
                
                updatePerfResults(results);
                log('üéâ Ë®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                
            } catch (error) {
                log(`‚ùå Ë®òÊÜ∂È´îÂ£ìÂäõÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updatePerfResults(`‚ùå Ë®òÊÜ∂È´îÊ∏¨Ë©¶Â§±Êïó: ${error.message}`);
            }
        };
        
        // ‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶
        window.performanceTestConcurrency = async function() {
            try {
                log('üîÑ ÈñãÂßã‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶...', 'info');
                updatePerfResults('‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶‰∏≠...');
                
                const startTime = performance.now();
                
                // ÂâµÂª∫3ÂÄãËªåÈÅìÁî®Êñº‰∏¶ÁôºÊ∏¨Ë©¶
                log('üìä ÂâµÂª∫3ÂÄãËªåÈÅìÁî®Êñº‰∏¶ÁôºÊ∏¨Ë©¶...', 'info');
                const concurrentTracks = [];
                
                for (let i = 0; i < 3; i++) {
                    const trackId = await musicService.createTrack('concurrent-test', 'INSTRUMENT', `Concurrent Track ${i + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 3000 },
                        { type: 'synth', name: `Concurrent Synth ${i + 1}` },
                        `Concurrent Clip ${i + 1}`
                    );
                    
                    // ÊØèÂÄãËªåÈÅì‰∏çÂêåÁöÑÈü≥Á¨¶Ê®°Âºè
                    const baseNote = 60 + (i * 12);
                    for (let j = 0; j < 20; j++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            baseNote + (j % 8),
                            100,
                            { startTime: j * 150, endTime: (j * 150) + 100 }
                        );
                    }
                    
                    await musicService.addTrackToAdapter(trackId);
                    concurrentTracks.push({ trackId, clipId });
                }
                
                // Ê∏¨Ë©¶‰∏¶ÁôºÊí≠Êîæ
                log('üìä Ê∏¨Ë©¶‰∏¶ÁôºÊí≠ÊîæÊÄßËÉΩ...', 'info');
                const concurrentStart = performance.now();
                
                // ÂêåÊôÇÊí≠ÊîæÊâÄÊúâËªåÈÅì
                const playPromises = concurrentTracks.map(track => 
                    musicService.playMidiClip(track.trackId, track.clipId)
                );
                
                await Promise.all(playPromises);
                
                const concurrentEnd = performance.now();
                const totalTime = performance.now() - startTime;
                
                const results = `
                    ‚úÖ ‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶ÂÆåÊàê
                    üìä ÂâµÂª∫3ËªåÈÅì60Èü≥Á¨¶: ${totalTime.toFixed(2)}ms
                    üîÑ ‰∏¶ÁôºÊí≠ÊîæÂïüÂãï: ${(concurrentEnd - concurrentStart).toFixed(2)}ms
                    üéµ ‰∏¶ÁôºÊÄßËÉΩ: ${(concurrentEnd - concurrentStart) < 200 ? 'ÂÑ™ÁßÄ' : 'ËâØÂ•Ω'}
                    ‚ö° Âπ≥ÂùáËªåÈÅìÈüøÊáâ: ${((concurrentEnd - concurrentStart) / 3).toFixed(2)}ms
                `;
                
                updatePerfResults(results);
                log('üéâ ‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                
                // ÂÅúÊ≠¢Êí≠Êîæ
                setTimeout(async () => {
                    await musicService.stopAllTracks();
                    log('üßπ ‰∏¶ÁôºÊ∏¨Ë©¶Ê∏ÖÁêÜÂÆåÊàê', 'info');
                }, 3000);
                
            } catch (error) {
                log(`‚ùå ‰∏¶ÁôºÊí≠ÊîæÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updatePerfResults(`‚ùå ‰∏¶ÁôºÊ∏¨Ë©¶Â§±Êïó: ${error.message}`);
            }
        };
        
        // Êõ¥Êñ∞ÊÄßËÉΩÊ∏¨Ë©¶ÁµêÊûúÈ°ØÁ§∫
        function updatePerfResults(results) {
            const resultsElement = document.getElementById('perfResults');
            if (resultsElement) {
                resultsElement.innerHTML = results.replace(/\n/g, '<br>');
            }
        }
        
        // ============ ÂÖ®Èù¢Ê∏¨Ë©¶Â•ó‰ª∂ÂØ¶Áèæ ============
        
        // Ê∏¨Ë©¶ÁãÄÊÖãÁÆ°ÁêÜ
        let testResults = {};
        let isTestRunning = false;
        let testAbortController = null;
        
        // Ê∏¨Ë©¶ÁµÑÊë∫Áñä/Â±ïÈñã
        window.toggleTestGroup = function(groupName) {
            const content = document.getElementById(`${groupName}-tests`);
            const icon = document.getElementById(`${groupName}-icon`);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = '‚ñº';
            } else {
                content.classList.add('expanded');
                icon.textContent = '‚ñ≤';
            }
        };
        
        // ÂïüÁî®/Á¶ÅÁî®Ê∏¨Ë©¶ÊåâÈàï
        function enableAllTestButtons() {
            const buttons = document.querySelectorAll('.test-group-content button');
            buttons.forEach(btn => btn.disabled = false);
        }
        
        function disableAllTestButtons() {
            const buttons = document.querySelectorAll('.test-group-content button');
            buttons.forEach(btn => btn.disabled = true);
        }
        
        // Êõ¥Êñ∞Ê∏¨Ë©¶ÁµêÊûúÊëòË¶Å
        function updateTestSummary() {
            const summary = document.getElementById('testResultsSummary');
            const total = Object.keys(testResults).length;
            const passed = Object.values(testResults).filter(r => r.status === 'passed').length;
            const failed = Object.values(testResults).filter(r => r.status === 'failed').length;
            const running = Object.values(testResults).filter(r => r.status === 'running').length;
            
            summary.innerHTML = `Á∏ΩË®à: ${total} | ‚úÖ ÈÄöÈÅé: ${passed} | ‚ùå Â§±Êïó: ${failed} | üîÑ ÈÅãË°å‰∏≠: ${running}`;
        }
        
        // ============ ÂäüËÉΩÊÄßÊ∏¨Ë©¶ ============
        
        // MIDIÁ≤æÁ¢∫ÊÄßÊ∏¨Ë©¶
        window.testMidiAccuracy = async function() {
            try {
                log('üéµ ÈñãÂßãMIDIÁ≤æÁ¢∫ÊÄßÊ∏¨Ë©¶...', 'info');
                testResults['midiAccuracy'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // Ê∏¨Ë©¶‰∏çÂêåMIDIÂÄºÁöÑÊ∫ñÁ¢∫ÊÄß
                const testTrackId = await musicService.createTrack('midi-test', 'INSTRUMENT', 'MIDIÁ≤æÁ¢∫ÊÄßÊ∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 3000 },
                    { type: 'synth', name: 'Accuracy Test Synth' },
                    'Accuracy Test Clip'
                );
                
                // Ê∏¨Ë©¶Èü≥Á¨¶: C4, E4, G4, C5 (Â§ß‰∏âÂíåÂº¶)
                const testNotes = [60, 64, 67, 72];
                const testVelocities = [80, 100, 120, 100];
                
                for (let i = 0; i < testNotes.length; i++) {
                    await musicService.addMidiNote(
                        testTrackId,
                        clipId,
                        testNotes[i],
                        testVelocities[i],
                        { startTime: i * 500, endTime: (i * 500) + 400 }
                    );
                    log(`üéµ Ê∏¨Ë©¶Èü≥Á¨¶: MIDI ${testNotes[i]}, velocity ${testVelocities[i]}`, 'debug');
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['midiAccuracy'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['midiAccuracy'].startTime,
                    details: '4ÂÄã‰∏çÂêåMIDIÈü≥Á¨¶ÂèäÂäõÂ∫¶Ê∏¨Ë©¶ÈÄöÈÅé'
                };
                
                log('‚úÖ MIDIÁ≤æÁ¢∫ÊÄßÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['midiAccuracy'] = { status: 'failed', error: error.message };
                log(`‚ùå MIDIÁ≤æÁ¢∫ÊÄßÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ËªåÈÅìÊìç‰ΩúÊ∏¨Ë©¶
        window.testTrackOperations = async function() {
            try {
                log('üéõÔ∏è ÈñãÂßãËªåÈÅìÊìç‰ΩúÊ∏¨Ë©¶...', 'info');
                testResults['trackOps'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // ÂãïÊÖãÂâµÂª∫Â§öÂÄãËªåÈÅì
                const trackIds = [];
                for (let i = 0; i < 5; i++) {
                    const trackId = await musicService.createTrack('track-ops', 'INSTRUMENT', `ÂãïÊÖãËªåÈÅì ${i + 1}`);
                    trackIds.push(trackId);
                    await musicService.addTrackToAdapter(trackId);
                    log(`üéõÔ∏è ÂâµÂª∫ËªåÈÅì ${i + 1}/5: ${trackId.substring(0, 12)}...`, 'debug');
                }
                
                // Ê∏¨Ë©¶‰∏¶ÁôºÊ∑ªÂä†Èü≥Á¨¶
                for (const trackId of trackIds) {
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 1000 },
                        { type: 'synth', name: 'Track Ops Synth' },
                        'Track Ops Clip'
                    );
                    
                    await musicService.addMidiNote(
                        trackId,
                        clipId,
                        60 + Math.floor(Math.random() * 12),
                        100,
                        { startTime: 0, endTime: 500 }
                    );
                }
                
                testResults['trackOps'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['trackOps'].startTime,
                    details: `${trackIds.length}ÂÄãËªåÈÅìÂãïÊÖãÂâµÂª∫ÂíåÊìç‰ΩúÊàêÂäü`
                };
                
                log('‚úÖ ËªåÈÅìÊìç‰ΩúÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['trackOps'] = { status: 'failed', error: error.message };
                log(`‚ùå ËªåÈÅìÊìç‰ΩúÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ÁâáÊÆµÊìç‰ΩúÊ∏¨Ë©¶  
        window.testClipOperations = async function() {
            try {
                log('‚úÇÔ∏è ÈñãÂßãÁâáÊÆµÊìç‰ΩúÊ∏¨Ë©¶...', 'info');
                testResults['clipOps'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('clip-ops', 'INSTRUMENT', 'ÁâáÊÆµÊìç‰ΩúÊ∏¨Ë©¶');
                
                // ÂâµÂª∫Â§öÂÄãÁâáÊÆµ
                const clipIds = [];
                for (let i = 0; i < 3; i++) {
                    const clipId = await musicService.createMidiClip(
                        testTrackId,
                        { startTime: 0, endTime: 1000 }, // ‰ΩøÁî®Âõ∫ÂÆöÁöÑ0-1000msÁØÑÂúç
                        { type: 'synth', name: `Clip ${i + 1}` },
                        `Ê∏¨Ë©¶ÁâáÊÆµ ${i + 1}`
                    );
                    clipIds.push(clipId);
                    
                    // ÊØèÂÄãÁâáÊÆµÊ∑ªÂä†‰∏çÂêåÁöÑÈü≥Á¨¶Ê®°Âºè
                    for (let j = 0; j < 4; j++) {
                        const noteStart = j * 200;
                        const noteEnd = noteStart + 150;
                        // Á¢∫‰øùÈü≥Á¨¶Âú®clipÁöÑ1000msÁØÑÂúçÂÖß
                        if (noteEnd <= 1000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                60 + (i * 4) + j,
                                100,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                        }
                    }
                    
                    log(`‚úÇÔ∏è ÁâáÊÆµ ${i + 1}/3 ÂâµÂª∫ÂÆåÊàê`, 'debug');
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                
                testResults['clipOps'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['clipOps'].startTime,
                    details: `${clipIds.length}ÂÄãMIDIÁâáÊÆµÂâµÂª∫ÂíåÊìç‰ΩúÊàêÂäü`
                };
                
                log('‚úÖ ÁâáÊÆµÊìç‰ΩúÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['clipOps'] = { status: 'failed', error: error.message };
                log(`‚ùå ÁâáÊÆµÊìç‰ΩúÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ Á©©ÂÆöÊÄßÊ∏¨Ë©¶ ============
        
        // ËÄê‰πÖÊÄßÊ∏¨Ë©¶
        window.testDurability = async function() {
            try {
                log('‚è±Ô∏è ÈñãÂßãËÄê‰πÖÊÄßÊ∏¨Ë©¶ (30ÁßíÈÄ£Á∫åÊìç‰Ωú)...', 'info');
                testResults['durability'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const endTime = Date.now() + 30000; // 30ÁßíÊ∏¨Ë©¶
                let operationCount = 0;
                
                while (Date.now() < endTime && !testAbortController?.signal.aborted) {
                    const trackId = await musicService.createTrack('durability', 'INSTRUMENT', `ËÄê‰πÖÊ∏¨Ë©¶ ${operationCount}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 500 },
                        { type: 'synth', name: 'Durability Synth' },
                        'Durability Clip'
                    );
                    
                    await musicService.addMidiNote(
                        trackId,
                        clipId,
                        60 + (operationCount % 12),
                        100,
                        { startTime: 0, endTime: 300 }
                    );
                    
                    operationCount++;
                    
                    if (operationCount % 10 === 0) {
                        log(`‚è±Ô∏è ËÄê‰πÖÊ∏¨Ë©¶ÈÄ≤Â∫¶: ${operationCount} Ê¨°Êìç‰Ωú`, 'debug');
                    }
                    
                    // Áü≠Êö´Âª∂ÈÅ≤ÈÅøÂÖçÈÅéËºâ
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                testResults['durability'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['durability'].startTime,
                    details: `30ÁßíÂÖßÂÆåÊàê ${operationCount} Ê¨°ÈÄ£Á∫åÊìç‰Ωú`
                };
                
                log('‚úÖ ËÄê‰πÖÊÄßÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['durability'] = { status: 'failed', error: error.message };
                log(`‚ùå ËÄê‰πÖÊÄßÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // Áï∞Â∏∏ËôïÁêÜÊ∏¨Ë©¶
        window.testExceptionHandling = async function() {
            try {
                log('üö® ÈñãÂßãÁï∞Â∏∏ËôïÁêÜÊ∏¨Ë©¶...', 'info');
                testResults['exceptions'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                let testsPassed = 0;
                const totalTests = 4;
                
                // Ê∏¨Ë©¶1: ÁÑ°ÊïàËªåÈÅìID
                try {
                    await musicService.playMidiClip('invalid-track-id', 'invalid-clip-id');
                    log('‚ö†Ô∏è ÁÑ°ÊïàIDÊ∏¨Ë©¶ - ÊáâË©≤ÊããÂá∫Áï∞Â∏∏‰ΩÜÊ≤íÊúâ', 'warning');
                } catch (e) {
                    log('‚úÖ ÁÑ°ÊïàIDÁï∞Â∏∏ËôïÁêÜÊ≠£Á¢∫', 'debug');
                    testsPassed++;
                }
                
                // Ê∏¨Ë©¶2: Ê•µÁ´ØMIDIÂÄº
                try {
                    const testTrackId = await musicService.createTrack('exception-test', 'INSTRUMENT', 'Áï∞Â∏∏ËôïÁêÜÊ∏¨Ë©¶');
                    const clipId = await musicService.createMidiClip(
                        testTrackId,
                        { startTime: 0, endTime: 1000 },
                        { type: 'synth', name: 'Exception Test' },
                        'Exception Clip'
                    );
                    
                    // Ê∏¨Ë©¶ÈÇäÁïåMIDIÂÄº
                    await musicService.addMidiNote(testTrackId, clipId, 0, 100, { startTime: 0, endTime: 100 });
                    await musicService.addMidiNote(testTrackId, clipId, 127, 100, { startTime: 100, endTime: 200 });
                    testsPassed++;
                    log('‚úÖ Ê•µÁ´ØMIDIÂÄºËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è Ê•µÁ´ØMIDIÂÄºÊ∏¨Ë©¶Â§±Êïó: ${e.message}`, 'warning');
                }
                
                // Ê∏¨Ë©¶3: ÁÑ°ÊïàÊôÇÈñìÁØÑÂúç
                try {
                    const testTrackId = await musicService.createTrack('time-test', 'INSTRUMENT', 'ÊôÇÈñìÊ∏¨Ë©¶');
                    const clipId = await musicService.createMidiClip(
                        testTrackId,
                        { startTime: 1000, endTime: 0 }, // ÁÑ°Êïà: ÁµêÊùüÊôÇÈñìÊó©ÊñºÈñãÂßãÊôÇÈñì
                        { type: 'synth', name: 'Time Test' },
                        'Time Clip'
                    );
                    log('‚ö†Ô∏è ÁÑ°ÊïàÊôÇÈñìÁØÑÂúç - ÊáâË©≤ÊããÂá∫Áï∞Â∏∏‰ΩÜÊ≤íÊúâ', 'warning');
                } catch (e) {
                    log('‚úÖ ÁÑ°ÊïàÊôÇÈñìÁØÑÂúçÁï∞Â∏∏ËôïÁêÜÊ≠£Á¢∫', 'debug');
                    testsPassed++;
                }
                
                // Ê∏¨Ë©¶4: Á©∫Êï∏ÊìöËôïÁêÜ
                try {
                    const testTrackId = await musicService.createTrack('empty-test', 'INSTRUMENT', '');
                    testsPassed++;
                    log('‚úÖ Á©∫Â≠óÁ¨¶‰∏≤ËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è Á©∫Â≠óÁ¨¶‰∏≤Ê∏¨Ë©¶: ${e.message}`, 'warning');
                }
                
                testResults['exceptions'] = { 
                    status: testsPassed >= 3 ? 'passed' : 'failed', 
                    duration: Date.now() - testResults['exceptions'].startTime,
                    details: `${testsPassed}/${totalTests} Áï∞Â∏∏ËôïÁêÜÊ∏¨Ë©¶ÈÄöÈÅé`
                };
                
                log('‚úÖ Áï∞Â∏∏ËôïÁêÜÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['exceptions'] = { status: 'failed', error: error.message };
                log(`‚ùå Áï∞Â∏∏ËôïÁêÜÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // Ë®òÊÜ∂È´îÊ¥©ÊºèÊ∏¨Ë©¶
        window.testMemoryLeaks = async function() {
            try {
                log('üîç ÈñãÂßãË®òÊÜ∂È´îÊ¥©ÊºèÊ∏¨Ë©¶...', 'info');
                testResults['memoryLeaks'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                // ÂâµÂª∫ÂíåÊ∏ÖÁêÜÂ§ßÈáèÂ∞çË±°
                for (let cycle = 0; cycle < 5; cycle++) {
                    const trackIds = [];
                    
                    // ÂâµÂª∫ÈöéÊÆµ
                    for (let i = 0; i < 20; i++) {
                        const trackId = await musicService.createTrack('memory-leak-test', 'INSTRUMENT', `Memory Test ${cycle}-${i}`);
                        const clipId = await musicService.createMidiClip(
                            trackId,
                            { startTime: 0, endTime: 1000 },
                            { type: 'synth', name: `Memory Synth ${i}` },
                            `Memory Clip ${i}`
                        );
                        
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (i % 12),
                            100,
                            { startTime: 0, endTime: 500 }
                        );
                        
                        trackIds.push(trackId);
                    }
                    
                    log(`üîç Ë®òÊÜ∂È´îÊ∏¨Ë©¶Âæ™Áí∞ ${cycle + 1}/5 - ÂâµÂª∫20ÂÄãËªåÈÅì`, 'debug');
                    
                    // Âº∑Âà∂ÂûÉÂúæÂõûÊî∂ (Â¶ÇÊûúÂèØËÉΩ)
                    if (window.gc) {
                        window.gc();
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = finalMemory - initialMemory;
                
                testResults['memoryLeaks'] = { 
                    status: memoryIncrease < 100 * 1024 * 1024 ? 'passed' : 'warning', // 100MBÈñæÂÄº
                    duration: Date.now() - testResults['memoryLeaks'].startTime,
                    details: `Ë®òÊÜ∂È´îÂ¢ûÈï∑: ${(memoryIncrease / 1024 / 1024).toFixed(2)} MB`
                };
                
                log('‚úÖ Ë®òÊÜ∂È´îÊ¥©ÊºèÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['memoryLeaks'] = { status: 'failed', error: error.message };
                log(`‚ùå Ë®òÊÜ∂È´îÊ¥©ÊºèÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ ÈÇäÁïåÊ∏¨Ë©¶ ============
        
        // Ê•µÈôêÂÄºÊ∏¨Ë©¶
        window.testExtremeValues = async function() {
            try {
                log('üéØ ÈñãÂßãÊ•µÈôêÂÄºÊ∏¨Ë©¶...', 'info');
                testResults['extremeValues'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('extreme-test', 'INSTRUMENT', 'Ê•µÈôêÂÄºÊ∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 10000 }, // Â¢ûÂä†Âà∞10Áßí
                    { type: 'synth', name: 'Extreme Test Synth' },
                    'Extreme Test Clip'
                );
                
                // Ê∏¨Ë©¶Ê•µÁ´ØMIDIÂÄº
                const extremeTests = [
                    { note: 0, velocity: 1, duration: 1 },     // ÊúÄ‰ΩéÈü≥Á¨¶ÔºåÊúÄÂ∞èÂäõÂ∫¶ÔºåÊúÄÁü≠ÊôÇÈï∑
                    { note: 127, velocity: 127, duration: 1 }, // ÊúÄÈ´òÈü≥Á¨¶ÔºåÊúÄÂ§ßÂäõÂ∫¶
                    { note: 60, velocity: 100, duration: 2000 }, // Èï∑ÊôÇÈï∑ (2Áßí)
                    { note: 60, velocity: 0, duration: 500 },  // Èõ∂ÂäõÂ∫¶
                ];
                
                for (let i = 0; i < extremeTests.length; i++) {
                    const test = extremeTests[i];
                    try {
                        const noteStart = i * 2500; // ÊØèÂÄãÊ∏¨Ë©¶ÈñìÈöî2.5Áßí
                        const noteEnd = noteStart + test.duration;
                        // Á¢∫‰øùÈü≥Á¨¶Âú®clipÁöÑ10000msÁØÑÂúçÂÖß
                        if (noteEnd <= 10000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                test.note,
                                test.velocity,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                            log(`üéØ Ê•µÈôêÊ∏¨Ë©¶ ${i + 1}/4: MIDI ${test.note}, velocity ${test.velocity}, duration ${test.duration}ms`, 'debug');
                        } else {
                            log(`‚ö†Ô∏è Ê•µÈôêÊ∏¨Ë©¶ ${i + 1} Ë∑≥ÈÅé: Èü≥Á¨¶Ë∂ÖÂá∫clipÁØÑÂúç`, 'warning');
                        }
                    } catch (e) {
                        log(`‚ö†Ô∏è Ê•µÈôêÊ∏¨Ë©¶ ${i + 1} Â§±Êïó: ${e.message}`, 'warning');
                    }
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                
                testResults['extremeValues'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['extremeValues'].startTime,
                    details: '4È†ÖÊ•µÈôêÂÄºÊ∏¨Ë©¶ÂÆåÊàê'
                };
                
                log('‚úÖ Ê•µÈôêÂÄºÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['extremeValues'] = { status: 'failed', error: error.message };
                log(`‚ùå Ê•µÈôêÂÄºÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // Â§ßË¶èÊ®°Ê∏¨Ë©¶
        window.testLargeScale = async function() {
            try {
                log('üìä ÈñãÂßãÂ§ßË¶èÊ®°Ê∏¨Ë©¶ (100ËªåÈÅì)...', 'info');
                testResults['largeScale'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const trackIds = [];
                
                // ÂâµÂª∫100ÂÄãËªåÈÅì
                for (let i = 0; i < 100; i++) {
                    const trackId = await musicService.createTrack('large-scale', 'INSTRUMENT', `Â§ßË¶èÊ®°Ê∏¨Ë©¶ËªåÈÅì ${i + 1}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 2000 },
                        { type: 'synth', name: `Large Scale Synth ${i}` },
                        `Large Scale Clip ${i}`
                    );
                    
                    // ÊØèÂÄãËªåÈÅìÊ∑ªÂä†10ÂÄãÈü≥Á¨¶
                    for (let j = 0; j < 10; j++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (j % 12),
                            100,
                            { startTime: j * 150, endTime: (j * 150) + 100 }
                        );
                    }
                    
                    trackIds.push(trackId);
                    
                    if ((i + 1) % 20 === 0) {
                        log(`üìä Â§ßË¶èÊ®°Ê∏¨Ë©¶ÈÄ≤Â∫¶: ${i + 1}/100 ËªåÈÅì`, 'debug');
                    }
                }
                
                testResults['largeScale'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['largeScale'].startTime,
                    details: `ÊàêÂäüÂâµÂª∫ ${trackIds.length} ÂÄãËªåÈÅìÔºåÂÖ± ${trackIds.length * 10} ÂÄãÈü≥Á¨¶`
                };
                
                log('‚úÖ Â§ßË¶èÊ®°Ê∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['largeScale'] = { status: 'failed', error: error.message };
                log(`‚ùå Â§ßË¶èÊ®°Ê∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ÈÇäÁïåÊÉÖÊ≥ÅÊ∏¨Ë©¶
        window.testEdgeCases = async function() {
            try {
                log('‚ö†Ô∏è ÈñãÂßãÈÇäÁïåÊÉÖÊ≥ÅÊ∏¨Ë©¶...', 'info');
                testResults['edgeCases'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                let casesPassed = 0;
                const totalCases = 5;
                
                // ÊÉÖÊ≥Å1: Èõ∂ÊôÇÈï∑ÁâáÊÆµ
                try {
                    const trackId = await musicService.createTrack('edge-test', 'INSTRUMENT', 'ÈÇäÁïåÊ∏¨Ë©¶');
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 1000, endTime: 1000 }, // Èõ∂ÊôÇÈï∑
                        { type: 'synth', name: 'Edge Test' },
                        'Edge Clip'
                    );
                    casesPassed++;
                    log('‚úÖ Èõ∂ÊôÇÈï∑ÁâáÊÆµËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è Èõ∂ÊôÇÈï∑ÁâáÊÆµÊ∏¨Ë©¶: ${e.message}`, 'warning');
                }
                
                // ÊÉÖÊ≥Å2: ÈáçÁñäÊôÇÈñìÊÆµ
                try {
                    const trackId = await musicService.createTrack('overlap-test', 'INSTRUMENT', 'ÈáçÁñäÊ∏¨Ë©¶');
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 2000 },
                        { type: 'synth', name: 'Overlap Test' },
                        'Overlap Clip'
                    );
                    
                    // Ê∑ªÂä†ÈáçÁñäÈü≥Á¨¶
                    await musicService.addMidiNote(trackId, clipId, 60, 100, { startTime: 0, endTime: 1000 });
                    await musicService.addMidiNote(trackId, clipId, 60, 100, { startTime: 500, endTime: 1500 });
                    casesPassed++;
                    log('‚úÖ ÈáçÁñäÈü≥Á¨¶ËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è ÈáçÁñäÈü≥Á¨¶Ê∏¨Ë©¶: ${e.message}`, 'warning');
                }
                
                // ÊÉÖÊ≥Å3: Ë∂ÖÂØÜÈõÜÈü≥Á¨¶ (ÊØèÊØ´Áßí‰∏ÄÂÄã)
                try {
                    const trackId = await musicService.createTrack('dense-test', 'INSTRUMENT', 'ÂØÜÈõÜÊ∏¨Ë©¶');
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 100 },
                        { type: 'synth', name: 'Dense Test' },
                        'Dense Clip'
                    );
                    
                    // 100ÂÄãÈü≥Á¨¶Âú®100ÊØ´ÁßíÂÖß
                    for (let i = 0; i < 100; i++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            60 + (i % 12),
                            100,
                            { startTime: i, endTime: i + 1 }
                        );
                    }
                    casesPassed++;
                    log('‚úÖ Ë∂ÖÂØÜÈõÜÈü≥Á¨¶ËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è Ë∂ÖÂØÜÈõÜÈü≥Á¨¶Ê∏¨Ë©¶: ${e.message}`, 'warning');
                }
                
                // ÊÉÖÊ≥Å4: Ê•µÈï∑ÂêçÁ®±
                try {
                    const longName = 'A'.repeat(1000); // 1000Â≠óÁ¨¶ÁöÑÂêçÁ®±
                    const trackId = await musicService.createTrack('long-name-test', 'INSTRUMENT', longName);
                    casesPassed++;
                    log('‚úÖ Ê•µÈï∑ÂêçÁ®±ËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è Ê•µÈï∑ÂêçÁ®±Ê∏¨Ë©¶: ${e.message}`, 'warning');
                }
                
                // ÊÉÖÊ≥Å5: ÁâπÊÆäÂ≠óÁ¨¶
                try {
                    const specialName = 'üéµüé∂‚ô™‚ô´üéºüéπü•Åüé∏üé∫üé∑üéª ÁâπÊÆäÂ≠óÁ¨¶Ê∏¨Ë©¶ !@#$%^&*()';
                    const trackId = await musicService.createTrack('special-char-test', 'INSTRUMENT', specialName);
                    casesPassed++;
                    log('‚úÖ ÁâπÊÆäÂ≠óÁ¨¶ËôïÁêÜÊ≠£Á¢∫', 'debug');
                } catch (e) {
                    log(`‚ö†Ô∏è ÁâπÊÆäÂ≠óÁ¨¶Ê∏¨Ë©¶: ${e.message}`, 'warning');
                }
                
                testResults['edgeCases'] = { 
                    status: casesPassed >= 3 ? 'passed' : 'failed', 
                    duration: Date.now() - testResults['edgeCases'].startTime,
                    details: `${casesPassed}/${totalCases} ÈÇäÁïåÊÉÖÊ≥ÅÊ∏¨Ë©¶ÈÄöÈÅé`
                };
                
                log('‚úÖ ÈÇäÁïåÊÉÖÊ≥ÅÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['edgeCases'] = { status: 'failed', error: error.message };
                log(`‚ùå ÈÇäÁïåÊÉÖÊ≥ÅÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ Èü≥Ê®ÇÊÄßÊ∏¨Ë©¶ ============
        
        // ÂíåËÅ≤Ê∏¨Ë©¶
        window.testHarmony = async function() {
            try {
                log('üéπ ÈñãÂßãÂíåËÅ≤Ê∏¨Ë©¶...', 'info');
                testResults['harmony'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('harmony-test', 'INSTRUMENT', 'ÂíåËÅ≤Ê∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 8000 },
                    { type: 'synth', name: 'Harmony Test Synth' },
                    'Harmony Test Clip'
                );
                
                // Ê∏¨Ë©¶‰∏çÂêåÂíåÂº¶
                const chords = [
                    { name: 'CÂ§ß‰∏âÂíåÂº¶', notes: [60, 64, 67], start: 0 },
                    { name: 'FÂ§ß‰∏âÂíåÂº¶', notes: [65, 69, 72], start: 1000 },
                    { name: 'GÂ§ß‰∏âÂíåÂº¶', notes: [67, 71, 74], start: 2000 },
                    { name: 'AmÂ∞è‰∏âÂíåÂº¶', notes: [69, 72, 76], start: 3000 },
                    { name: 'CÂ§ß‰∏ÉÂíåÂº¶', notes: [60, 64, 67, 71], start: 4000 },
                    { name: 'Ê∏õ‰∏ÉÂíåÂº¶', notes: [60, 63, 66, 69], start: 5000 },
                    { name: 'Â¢û‰∏âÂíåÂº¶', notes: [60, 64, 68], start: 6000 },
                    { name: 'ÊéõÂõõÂíåÂº¶', notes: [60, 65, 67], start: 7000 },
                ];
                
                for (const chord of chords) {
                    for (let i = 0; i < chord.notes.length; i++) {
                        await musicService.addMidiNote(
                            testTrackId,
                            clipId,
                            chord.notes[i],
                            100,
                            { startTime: chord.start, endTime: chord.start + 800 }
                        );
                    }
                    log(`üéπ ${chord.name} (${chord.notes.join(',')})`, 'debug');
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['harmony'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['harmony'].startTime,
                    details: `${chords.length}Á®ÆÂíåÂº¶È°ûÂûãÊ∏¨Ë©¶ÂÆåÊàê`
                };
                
                log('‚úÖ ÂíåËÅ≤Ê∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['harmony'] = { status: 'failed', error: error.message };
                log(`‚ùå ÂíåËÅ≤Ê∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ÁØÄÂ•èÊ∏¨Ë©¶
        window.testRhythm = async function() {
            try {
                log('ü•Å ÈñãÂßãÁØÄÂ•èÊ∏¨Ë©¶...', 'info');
                testResults['rhythm'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('rhythm-test', 'INSTRUMENT', 'ÁØÄÂ•èÊ∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 12000 }, // Â¢ûÂä†Âà∞12Áßí‰ª•ÂÆπÁ¥çÊâÄÊúâÁØÄÂ•èÊ®°Âºè
                    { type: 'synth', name: 'Rhythm Test Synth' },
                    'Rhythm Test Clip'
                );
                
                // Ê∏¨Ë©¶‰∏çÂêåÁØÄÂ•èÊ®°Âºè
                const rhythms = [
                    { name: 'ÂõõÂàÜÈü≥Á¨¶', pattern: [0, 500, 1000, 1500] },
                    { name: 'ÂÖ´ÂàÜÈü≥Á¨¶', pattern: [0, 250, 500, 750, 1000, 1250, 1500, 1750] },
                    { name: '‰∏âÈÄ£Èü≥', pattern: [0, 333, 667, 1000, 1333, 1667] },
                    { name: '‰∫îÈÄ£Èü≥', pattern: [0, 200, 400, 600, 800, 1000] },
                    { name: 'ÂàáÂàÜÈü≥', pattern: [0, 250, 750, 1250, 1750] },
                ];
                
                let currentTime = 0;
                for (const rhythm of rhythms) {
                    for (const offset of rhythm.pattern) {
                        const noteStart = currentTime + offset;
                        const noteEnd = noteStart + 100;
                        // Á¢∫‰øùÈü≥Á¨¶Âú®clipÁöÑ12000msÁØÑÂúçÂÖß
                        if (noteEnd <= 12000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                60,
                                100,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                        }
                    }
                    log(`ü•Å ${rhythm.name} ÁØÄÂ•èÊ®°Âºè`, 'debug');
                    currentTime += 2000; // ÊØèÂÄãÊ®°ÂºèÈñìÈöî2Áßí
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['rhythm'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['rhythm'].startTime,
                    details: `${rhythms.length}Á®ÆÁØÄÂ•èÊ®°ÂºèÊ∏¨Ë©¶ÂÆåÊàê`
                };
                
                log('‚úÖ ÁØÄÂ•èÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['rhythm'] = { status: 'failed', error: error.message };
                log(`‚ùå ÁØÄÂ•èÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // Èü≥ÈöéÊ∏¨Ë©¶
        window.testScales = async function() {
            try {
                log('üé∂ ÈñãÂßãÈü≥ÈöéÊ∏¨Ë©¶...', 'info');
                testResults['scales'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('scales-test', 'INSTRUMENT', 'Èü≥ÈöéÊ∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 15000 }, // Â¢ûÂä†Âà∞15Áßí‰ª•ÂÆπÁ¥çÊâÄÊúâÈü≥Èöé
                    { type: 'synth', name: 'Scales Test Synth' },
                    'Scales Test Clip'
                );
                
                // Ê∏¨Ë©¶‰∏çÂêåÈü≥Èöé
                const scales = [
                    { name: 'CÂ§ßË™ø', intervals: [0, 2, 4, 5, 7, 9, 11, 12] },
                    { name: 'AÂ∞èË™ø', intervals: [0, 2, 3, 5, 7, 8, 10, 12] },
                    { name: '‰∫îËÅ≤Èü≥Èöé', intervals: [0, 2, 4, 7, 9, 12] },
                    { name: 'Â∏ÉÈ≠ØÊñØÈü≥Èöé', intervals: [0, 3, 5, 6, 7, 10, 12] },
                    { name: 'ÂÖ®Èü≥Èöé', intervals: [0, 2, 4, 6, 8, 10, 12] },
                    { name: 'ÂçäÈü≥Èöé', intervals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] },
                ];
                
                let currentTime = 0;
                for (const scale of scales) {
                    for (let i = 0; i < scale.intervals.length; i++) {
                        const midiNote = 60 + scale.intervals[i]; // ÂæûC4ÈñãÂßã
                        const noteStart = currentTime + (i * 200);
                        const noteEnd = noteStart + 150;
                        // Á¢∫‰øùÈü≥Á¨¶Âú®clipÁöÑ15000msÁØÑÂúçÂÖß
                        if (noteEnd <= 15000) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                midiNote,
                                100,
                                { startTime: noteStart, endTime: noteEnd }
                            );
                        }
                    }
                    log(`üé∂ ${scale.name} (${scale.intervals.length}Èü≥)`, 'debug');
                    currentTime += scale.intervals.length * 200 + 500; // Èü≥ÈöéÈñìÈñìÈöî
                }
                
                await musicService.addTrackToAdapter(testTrackId);
                await musicService.playMidiClip(testTrackId, clipId);
                
                testResults['scales'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['scales'].startTime,
                    details: `${scales.length}Á®ÆÈü≥ÈöéÈ°ûÂûãÊ∏¨Ë©¶ÂÆåÊàê`
                };
                
                log('‚úÖ Èü≥ÈöéÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['scales'] = { status: 'failed', error: error.message };
                log(`‚ùå Èü≥ÈöéÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ Áî®Êà∂È´îÈ©óÊ∏¨Ë©¶ ============
        
        // ÈüøÊáâÊÄßÊ∏¨Ë©¶
        window.testResponsiveness = async function() {
            try {
                log('‚ö° ÈñãÂßãÈüøÊáâÊÄßÊ∏¨Ë©¶...', 'info');
                testResults['responsiveness'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const responseTimes = [];
                
                // Ê∏¨Ë©¶10Ê¨°Âø´ÈÄüÊìç‰ΩúÁöÑÈüøÊáâÊôÇÈñì
                for (let i = 0; i < 10; i++) {
                    const opStart = performance.now();
                    
                    const trackId = await musicService.createTrack('response-test', 'INSTRUMENT', `ÈüøÊáâÊ∏¨Ë©¶ ${i}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 1000 },
                        { type: 'synth', name: 'Response Test' },
                        'Response Clip'
                    );
                    await musicService.addMidiNote(trackId, clipId, 60, 100, { startTime: 0, endTime: 500 });
                    
                    const opEnd = performance.now();
                    const responseTime = opEnd - opStart;
                    responseTimes.push(responseTime);
                    
                    log(`‚ö° Êìç‰Ωú ${i + 1}/10: ${responseTime.toFixed(2)}ms`, 'debug');
                }
                
                const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
                const maxResponseTime = Math.max(...responseTimes);
                
                testResults['responsiveness'] = { 
                    status: avgResponseTime < 500 ? 'passed' : 'warning', 
                    duration: Date.now() - testResults['responsiveness'].startTime,
                    details: `Âπ≥ÂùáÈüøÊáâ: ${avgResponseTime.toFixed(2)}ms, ÊúÄÂ§ß: ${maxResponseTime.toFixed(2)}ms`
                };
                
                log('‚úÖ ÈüøÊáâÊÄßÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['responsiveness'] = { status: 'failed', error: error.message };
                log(`‚ùå ÈüøÊáâÊÄßÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // Èü≥Ë≥™Ê∏¨Ë©¶
        window.testAudioQuality = async function() {
            try {
                log('üîä ÈñãÂßãÈü≥Ë≥™Ê∏¨Ë©¶...', 'info');
                testResults['audioQuality'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // ÂâµÂª∫Â§öËªåÈÅìÊ∑∑Èü≥Ê∏¨Ë©¶
                const trackIds = [];
                
                // ÂâµÂª∫3ÂÄã‰∏çÂêåÈü≥ÂüüÁöÑËªåÈÅì
                const ranges = [
                    { name: '‰ΩéÈü≥', base: 36, count: 4 },  // C2-E2
                    { name: '‰∏≠Èü≥', base: 60, count: 4 },  // C4-E4  
                    { name: 'È´òÈü≥', base: 84, count: 4 },  // C6-E6
                ];
                
                for (const range of ranges) {
                    const trackId = await musicService.createTrack('audio-quality', 'INSTRUMENT', `Èü≥Ë≥™Ê∏¨Ë©¶_${range.name}`);
                    const clipId = await musicService.createMidiClip(
                        trackId,
                        { startTime: 0, endTime: 3000 },
                        { type: 'synth', name: `Quality Test ${range.name}` },
                        `Quality Clip ${range.name}`
                    );
                    
                    // ÊØèÂÄãÈü≥ÂüüÊ∑ªÂä†ÂíåÂº¶
                    for (let i = 0; i < range.count; i++) {
                        await musicService.addMidiNote(
                            trackId,
                            clipId,
                            range.base + (i * 2), // Â§ß‰∫åÂ∫¶ÈñìÈöî
                            100,
                            { startTime: 0, endTime: 2500 }
                        );
                    }
                    
                    await musicService.addTrackToAdapter(trackId);
                    trackIds.push(trackId);
                    log(`üîä ${range.name}Èü≥ÂüüËªåÈÅìÂâµÂª∫ÂÆåÊàê`, 'debug');
                }
                
                // Ê∏¨Ë©¶ÂêåÊôÇÊí≠Êîæ
                log('üîä Ê∏¨Ë©¶Â§öËªåÈÅìÊ∑∑Èü≥...', 'debug');
                await musicService.playAllTracks();
                
                testResults['audioQuality'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['audioQuality'].startTime,
                    details: `${trackIds.length}ËªåÈÅìÈü≥Ë≥™Ê∏¨Ë©¶ÂÆåÊàê`
                };
                
                log('‚úÖ Èü≥Ë≥™Ê∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['audioQuality'] = { status: 'failed', error: error.message };
                log(`‚ùå Èü≥Ë≥™Ê∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ÂØ¶ÊôÇÁ∑®ËºØÊ∏¨Ë©¶
        window.testRealTimeEditing = async function() {
            try {
                log('‚úèÔ∏è ÈñãÂßãÂØ¶ÊôÇÁ∑®ËºØÊ∏¨Ë©¶...', 'info');
                testResults['realTimeEditing'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                const testTrackId = await musicService.createTrack('realtime-test', 'INSTRUMENT', 'ÂØ¶ÊôÇÁ∑®ËºØÊ∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    testTrackId,
                    { startTime: 0, endTime: 5000 },
                    { type: 'synth', name: 'Realtime Test Synth' },
                    'Realtime Test Clip'
                );
                
                await musicService.addTrackToAdapter(testTrackId);
                
                // ÂàùÂßãÈü≥Á¨¶
                const noteIds = [];
                for (let i = 0; i < 5; i++) {
                    const noteId = await musicService.addMidiNote(
                        testTrackId,
                        clipId,
                        60 + i,
                        100,
                        { startTime: i * 800, endTime: (i * 800) + 600 }
                    );
                    noteIds.push(noteId);
                }
                
                log('‚úèÔ∏è ÈñãÂßãÊí≠Êîæ‰∏¶ÂØ¶ÊôÇÊ∑ªÂä†Èü≥Á¨¶...', 'debug');
                await musicService.playMidiClip(testTrackId, clipId);
                
                // Êí≠ÊîæÊúüÈñìÂãïÊÖãÊ∑ªÂä†Èü≥Á¨¶ (Ê®°Êì¨ÂØ¶ÊôÇÁ∑®ËºØ)
                setTimeout(async () => {
                    try {
                        for (let i = 0; i < 3; i++) {
                            await musicService.addMidiNote(
                                testTrackId,
                                clipId,
                                65 + i,
                                80,
                                { startTime: 2000 + (i * 500), endTime: 2000 + (i * 500) + 400 }
                            );
                            log(`‚úèÔ∏è ÂØ¶ÊôÇÊ∑ªÂä†Èü≥Á¨¶ ${i + 1}/3`, 'debug');
                        }
                    } catch (e) {
                        log(`‚ö†Ô∏è ÂØ¶ÊôÇÁ∑®ËºØÈÅéÁ®ã‰∏≠Âá∫ÁèæÂïèÈ°å: ${e.message}`, 'warning');
                    }
                }, 1000);
                
                testResults['realTimeEditing'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['realTimeEditing'].startTime,
                    details: 'ÂØ¶ÊôÇÁ∑®ËºØÂäüËÉΩÊ∏¨Ë©¶ÂÆåÊàê'
                };
                
                log('‚úÖ ÂØ¶ÊôÇÁ∑®ËºØÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['realTimeEditing'] = { status: 'failed', error: error.message };
                log(`‚ùå ÂØ¶ÊôÇÁ∑®ËºØÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ Êï¥ÂêàÊ∏¨Ë©¶ ============
        
        // Ë∑®ÂäüËÉΩÊ∏¨Ë©¶
        window.testCrossFeatures = async function() {
            try {
                log('üéØ ÈñãÂßãË∑®ÂäüËÉΩÊ∏¨Ë©¶...', 'info');
                testResults['crossFeatures'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // Ê∏¨Ë©¶Êí≠Êîæ‰∏≠Á∑®ËºØ
                const trackId = await musicService.createTrack('cross-test', 'INSTRUMENT', 'Ë∑®ÂäüËÉΩÊ∏¨Ë©¶');
                const clipId = await musicService.createMidiClip(
                    trackId,
                    { startTime: 0, endTime: 6000 },
                    { type: 'synth', name: 'Cross Feature Test' },
                    'Cross Feature Clip'
                );
                
                // Ê∑ªÂä†ÂàùÂßãÈü≥Á¨¶
                for (let i = 0; i < 8; i++) {
                    await musicService.addMidiNote(
                        trackId,
                        clipId,
                        60 + (i % 7),
                        100,
                        { startTime: i * 500, endTime: (i * 500) + 400 }
                    );
                }
                
                await musicService.addTrackToAdapter(trackId);
                
                // ÈñãÂßãÊí≠Êîæ
                await musicService.playMidiClip(trackId, clipId);
                log('üéØ ÈñãÂßãÊí≠Êîæ‰∏¶Ê∏¨Ë©¶‰∏¶ÁôºÊìç‰Ωú...', 'debug');
                
                // ‰∏¶ÁôºÂü∑Ë°åÂ§öÈ†ÖÊìç‰Ωú
                const operations = [];
                
                // Êìç‰Ωú1: ÂâµÂª∫Êñ∞ËªåÈÅì
                operations.push(
                    musicService.createTrack('concurrent', 'INSTRUMENT', '‰∏¶ÁôºÊ∏¨Ë©¶ËªåÈÅì')
                );
                
                // Êìç‰Ωú2: Ë™øË©¶ÂäüËÉΩ
                operations.push(
                    musicService.debugAdapterState()
                );
                
                // Êìç‰Ωú3: Ê∑ªÂä†Êõ¥Â§öÈü≥Á¨¶
                operations.push(
                    musicService.addMidiNote(
                        trackId,
                        clipId,
                        72,
                        120,
                        { startTime: 4000, endTime: 4500 }
                    )
                );
                
                // Á≠âÂæÖÊâÄÊúâÊìç‰ΩúÂÆåÊàê
                await Promise.all(operations);
                
                testResults['crossFeatures'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['crossFeatures'].startTime,
                    details: 'Êí≠Êîæ‰∏≠‰∏¶ÁôºÁ∑®ËºØÊ∏¨Ë©¶ÂÆåÊàê'
                };
                
                log('‚úÖ Ë∑®ÂäüËÉΩÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['crossFeatures'] = { status: 'failed', error: error.message };
                log(`‚ùå Ë∑®ÂäüËÉΩÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // Êï∏ÊìöÊåÅ‰πÖÂåñÊ∏¨Ë©¶
        window.testDataPersistence = async function() {
            try {
                log('üíæ ÈñãÂßãÊï∏ÊìöÊåÅ‰πÖÂåñÊ∏¨Ë©¶...', 'info');
                testResults['dataPersistence'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // ÂâµÂª∫Ë§áÈõúÁöÑÈü≥Ê®ÇÁµêÊßã
                const trackData = [];
                
                for (let i = 0; i < 3; i++) {
                    const trackId = await musicService.createTrack('persist-test', 'INSTRUMENT', `ÊåÅ‰πÖÂåñÊ∏¨Ë©¶ËªåÈÅì ${i + 1}`);
                    const clipIds = [];
                    
                    // ÊØèÂÄãËªåÈÅìÂâµÂª∫2ÂÄãÁâáÊÆµ
                    for (let j = 0; j < 2; j++) {
                        const clipId = await musicService.createMidiClip(
                            trackId,
                            { startTime: 0, endTime: 1500 }, // ‰ΩøÁî®Âõ∫ÂÆöÁöÑ0-1500msÁØÑÂúç
                            { type: 'synth', name: `Persist Synth ${i}-${j}` },
                            `Persist Clip ${i}-${j}`
                        );
                        
                        // ÊØèÂÄãÁâáÊÆµÊ∑ªÂä†Èü≥Á¨¶ - Á¢∫‰øùÈü≥Á¨¶Âú®clipÁØÑÂúçÂÖß
                        for (let k = 0; k < 5; k++) {
                            const noteStart = k * 200;
                            const noteEnd = noteStart + 150;
                            // Á¢∫‰øùÈü≥Á¨¶Âú®ÁâáÊÆµÁöÑ1500msÁØÑÂúçÂÖß
                            if (noteEnd <= 1500) {
                                await musicService.addMidiNote(
                                    trackId,
                                    clipId,
                                    60 + (i * 5) + k,
                                    100,
                                    { startTime: noteStart, endTime: noteEnd }
                                );
                            }
                        }
                        
                        clipIds.push(clipId);
                    }
                    
                    trackData.push({ trackId, clipIds });
                    await musicService.addTrackToAdapter(trackId);
                }
                
                log('üíæ Ê∏¨Ë©¶Êï∏ÊìöÁµêÊßãÂâµÂª∫ÂÆåÊàê', 'debug');
                
                // Ê∏¨Ë©¶Ë™øË©¶ÂäüËÉΩÔºàÈñìÊé•Ê∏¨Ë©¶Êï∏ÊìöÊåÅ‰πÖÊÄßÔºâ
                await musicService.debugAdapterState();
                
                for (const track of trackData) {
                    await musicService.debugAudioChain(track.trackId);
                }
                
                testResults['dataPersistence'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['dataPersistence'].startTime,
                    details: `${trackData.length}ËªåÈÅìÊï∏ÊìöÊåÅ‰πÖÂåñÊ∏¨Ë©¶ÂÆåÊàê`
                };
                
                log('‚úÖ Êï∏ÊìöÊåÅ‰πÖÂåñÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['dataPersistence'] = { status: 'failed', error: error.message };
                log(`‚ùå Êï∏ÊìöÊåÅ‰πÖÂåñÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ÂÆåÊï¥Â∑•‰ΩúÊµÅÊ∏¨Ë©¶
        window.testFullWorkflow = async function() {
            try {
                log('üîÑ ÈñãÂßãÂÆåÊï¥Â∑•‰ΩúÊµÅÊ∏¨Ë©¶...', 'info');
                testResults['fullWorkflow'] = { status: 'running', startTime: Date.now() };
                updateTestSummary();
                
                // Ê®°Êì¨ÂÆåÊï¥ÁöÑÈü≥Ê®ÇË£Ω‰ΩúÊµÅÁ®ã
                
                // 1. ÂâµÂª∫È†ÖÁõÆÁµêÊßã
                log('üîÑ Ê≠•È©ü1: ÂâµÂª∫È†ÖÁõÆÁµêÊßã...', 'debug');
                const tracks = [];
                
                const trackTypes = [
                    { name: 'ÈºìÁµÑËªåÈÅì', noteRange: [36, 42] },
                    { name: 'Ë≤ùÊñØËªåÈÅì', noteRange: [28, 48] },
                    { name: 'ÂíåÂº¶ËªåÈÅì', noteRange: [48, 72] },
                    { name: '‰∏ªÊóãÂæãËªåÈÅì', noteRange: [60, 84] },
                ];
                
                for (const trackType of trackTypes) {
                    const trackId = await musicService.createTrack('workflow-test', 'INSTRUMENT', trackType.name);
                    await musicService.addTrackToAdapter(trackId);
                    tracks.push({ trackId, ...trackType });
                }
                
                // 2. Â°´ÂÖÖÈü≥Ê®ÇÂÖßÂÆπ
                log('üîÑ Ê≠•È©ü2: Â°´ÂÖÖÈü≥Ê®ÇÂÖßÂÆπ...', 'debug');
                for (const track of tracks) {
                    const clipId = await musicService.createMidiClip(
                        track.trackId,
                        { startTime: 0, endTime: 8000 },
                        { type: 'synth', name: `${track.name} Synth` },
                        `${track.name} Clip`
                    );
                    
                    // Ê†πÊìöËªåÈÅìÈ°ûÂûãÊ∑ªÂä†ÈÅ©Áï∂ÁöÑÈü≥Á¨¶
                    const noteCount = track.name.includes('ÈºìÁµÑ') ? 16 : 8;
                    for (let i = 0; i < noteCount; i++) {
                        const noteRange = track.noteRange[1] - track.noteRange[0];
                        const note = track.noteRange[0] + (i % noteRange);
                        const startTime = (i * 8000) / noteCount;
                        
                        await musicService.addMidiNote(
                            track.trackId,
                            clipId,
                            note,
                            100,
                            { startTime, endTime: startTime + 200 }
                        );
                    }
                }
                
                // 3. Ê∏¨Ë©¶Êí≠Êîæ
                log('üîÑ Ê≠•È©ü3: Ê∏¨Ë©¶ÂÆåÊï¥Êí≠Êîæ...', 'debug');
                await musicService.playAllTracks();
                
                // 4. Ê∏¨Ë©¶ÂÅúÊ≠¢
                setTimeout(async () => {
                    log('üîÑ Ê≠•È©ü4: Ê∏¨Ë©¶ÂÅúÊ≠¢ÂäüËÉΩ...', 'debug');
                    await musicService.stopAllTracks();
                }, 3000);
                
                // 5. Ê∏¨Ë©¶ÁãÄÊÖãÊ™¢Êü•
                log('üîÑ Ê≠•È©ü5: Ê™¢Êü•Á≥ªÁµ±ÁãÄÊÖã...', 'debug');
                await musicService.debugAdapterState();
                
                testResults['fullWorkflow'] = { 
                    status: 'passed', 
                    duration: Date.now() - testResults['fullWorkflow'].startTime,
                    details: `ÂÆåÊï¥Â∑•‰ΩúÊµÅÁ®ã (${tracks.length}ËªåÈÅì) Ê∏¨Ë©¶ÂÆåÊàê`
                };
                
                log('‚úÖ ÂÆåÊï¥Â∑•‰ΩúÊµÅÊ∏¨Ë©¶ÂÆåÊàê', 'success');
                updateTestSummary();
                
            } catch (error) {
                testResults['fullWorkflow'] = { status: 'failed', error: error.message };
                log(`‚ùå ÂÆåÊï¥Â∑•‰ΩúÊµÅÊ∏¨Ë©¶Â§±Êïó: ${error.message}`, 'error');
                updateTestSummary();
            }
        };
        
        // ============ Ê∏¨Ë©¶ÊéßÂà∂ÂäüËÉΩ ============
        
        // ÈÅãË°åÂÖ®ÈÉ®Ê∏¨Ë©¶
        window.runAllTests = async function() {
            try {
                log('üöÄ ÈñãÂßãÈÅãË°åÂÖ®ÈÉ®Ê∏¨Ë©¶...', 'info');
                isTestRunning = true;
                testAbortController = new AbortController();
                
                // Ê∏ÖÁ©∫‰πãÂâçÁöÑÁµêÊûú
                testResults = {};
                updateTestSummary();
                
                const testFunctions = [
                    // ÂäüËÉΩÊÄßÊ∏¨Ë©¶
                    testMidiAccuracy,
                    testTrackOperations, 
                    testClipOperations,
                    // Á©©ÂÆöÊÄßÊ∏¨Ë©¶
                    testDurability,
                    testExceptionHandling,
                    testMemoryLeaks,
                    // ÈÇäÁïåÊ∏¨Ë©¶
                    testExtremeValues,
                    testLargeScale,
                    testEdgeCases,
                    // Èü≥Ê®ÇÊÄßÊ∏¨Ë©¶
                    testHarmony,
                    testRhythm,
                    testScales,
                    // Áî®Êà∂È´îÈ©óÊ∏¨Ë©¶
                    testResponsiveness,
                    testAudioQuality,
                    testRealTimeEditing,
                    // Êï¥ÂêàÊ∏¨Ë©¶
                    testCrossFeatures,
                    testDataPersistence,
                    testFullWorkflow,
                ];
                
                log(`üìä Â∞á‰æùÂ∫èÂü∑Ë°å ${testFunctions.length} ÂÄãÊ∏¨Ë©¶...`, 'info');
                
                for (let i = 0; i < testFunctions.length; i++) {
                    if (testAbortController.signal.aborted) {
                        log('‚èπÔ∏è Ê∏¨Ë©¶Ë¢´Áî®Êà∂‰∏≠Êñ∑', 'warning');
                        break;
                    }
                    
                    log(`üîÑ Âü∑Ë°åÊ∏¨Ë©¶ ${i + 1}/${testFunctions.length}...`, 'info');
                    await testFunctions[i]();
                    
                    // Ê∏¨Ë©¶ÈñìÁü≠Êö´ÈñìÈöî
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Á∏ΩÁµêÊ∏¨Ë©¶ÁµêÊûú
                const total = Object.keys(testResults).length;
                const passed = Object.values(testResults).filter(r => r.status === 'passed').length;
                const failed = Object.values(testResults).filter(r => r.status === 'failed').length;
                const warnings = Object.values(testResults).filter(r => r.status === 'warning').length;
                
                log('üéâ ÂÖ®ÈÉ®Ê∏¨Ë©¶ÂÆåÊàêÔºÅ', 'success');
                log(`üìä Ê∏¨Ë©¶Á∏ΩÁµê: ${total}È†ÖÊ∏¨Ë©¶ | ‚úÖ${passed}ÈÄöÈÅé | ‚ùå${failed}Â§±Êïó | ‚ö†Ô∏è${warnings}Ë≠¶Âëä`, 'info');
                
                isTestRunning = false;
                
            } catch (error) {
                log(`‚ùå Ê∏¨Ë©¶ÈÅãË°åÂ§±Êïó: ${error.message}`, 'error');
                isTestRunning = false;
            }
        };
        
        // ÂÅúÊ≠¢ÊâÄÊúâÊ∏¨Ë©¶
        window.stopAllTests = function() {
            if (isTestRunning && testAbortController) {
                testAbortController.abort();
                log('‚èπÔ∏è Ê≠£Âú®ÂÅúÊ≠¢ÊâÄÊúâÊ∏¨Ë©¶...', 'warning');
                isTestRunning = false;
            }
        };
        
        // ÈÅãË°åÈÅ∏‰∏≠Ê∏¨Ë©¶ (Á∞°ÂåñÂØ¶Áèæ)
        window.runSelectedTests = async function() {
            log('‚úÖ ÈÅãË°åÈÅ∏‰∏≠Ê∏¨Ë©¶ÂäüËÉΩ (Á§∫‰æãÂØ¶Áèæ)', 'info');
            // ÈÄôË£°ÂèØ‰ª•ÂØ¶ÁèæÂü∫ÊñºÁî®Êà∂ÈÅ∏ÊìáÁöÑÊ∏¨Ë©¶ÈÅãË°åÈÇèËºØ
            await testMidiAccuracy();
            await testResponsiveness();
            log('‚úÖ ÈÅ∏‰∏≠Ê∏¨Ë©¶ÂÆåÊàê', 'success');
        };
    </script>
</body>
</html> 